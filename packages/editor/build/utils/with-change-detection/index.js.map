{"version":3,"sources":["@wordpress/editor/src/utils/with-change-detection/index.js"],"names":["withChangeDetection","options","reducer","state","action","nextState","isReset","undefined","resetTypes","type","isChanging","isIgnored","ignoreTypes","isDirty"],"mappings":";;;;;;;;;;;AAGA;;AAHA;;;;AAKA;;;;;;;;;;;AAWA,IAAMA,mBAAmB,GAAG,SAAtBA,mBAAsB;AAAA,MAAEC,OAAF,uEAAY,EAAZ;AAAA,SAAoB,UAAEC,OAAF,EAAe;AAC9D,WAAO,UAAEC,KAAF,EAASC,MAAT,EAAqB;AAC3B,UAAIC,SAAS,GAAGH,OAAO,CAAEC,KAAF,EAASC,MAAT,CAAvB,CAD2B,CAG3B;AACA;AACA;;AACA,UAAME,OAAO,GACZH,KAAK,KAAKI,SAAV,IACA,sBAAUN,OAAO,CAACO,UAAlB,EAA8BJ,MAAM,CAACK,IAArC,CAFD;AAKA,UAAMC,UAAU,GAAGP,KAAK,KAAKE,SAA7B,CAX2B,CAa3B;;AACA,UAAK,CAAEK,UAAF,IAAgB,CAAEJ,OAAvB,EAAiC;AAChC,eAAOH,KAAP;AACA,OAhB0B,CAkB3B;AACA;;;AACA,UAAK,CAAEO,UAAF,IAAgBP,KAAK,KAAKI,SAA/B,EAA2C;AAC1CF,QAAAA,SAAS,mCAAQA,SAAR,CAAT;AACA;;AAED,UAAMM,SAAS,GAAG,sBAAUV,OAAO,CAACW,WAAlB,EAA+BR,MAAM,CAACK,IAAtC,CAAlB;;AAEA,UAAKE,SAAL,EAAiB;AAChB;AACAN,QAAAA,SAAS,CAACQ,OAAV,GAAoBV,KAAK,CAACU,OAA1B;AACA,OAHD,MAGO;AACNR,QAAAA,SAAS,CAACQ,OAAV,GAAoB,CAAEP,OAAF,IAAaI,UAAjC;AACA;;AAED,aAAOL,SAAP;AACA,KAlCD;AAmCA,GApC2B;AAAA,CAA5B;;eAsCeL,mB","sourcesContent":["/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Higher-order reducer creator for tracking changes to state over time. The\n * returned reducer will include a `isDirty` property on the object reflecting\n * whether the original reference of the reducer has changed.\n *\n * @param {?Object} options             Optional options.\n * @param {?Array}  options.ignoreTypes Action types upon which to skip check.\n * @param {?Array}  options.resetTypes  Action types upon which to reset dirty.\n *\n * @return {Function} Higher-order reducer.\n */\nconst withChangeDetection = ( options = {} ) => ( reducer ) => {\n\treturn ( state, action ) => {\n\t\tlet nextState = reducer( state, action );\n\n\t\t// Reset at:\n\t\t//  - Initial state\n\t\t//  - Reset types\n\t\tconst isReset = (\n\t\t\tstate === undefined ||\n\t\t\tincludes( options.resetTypes, action.type )\n\t\t);\n\n\t\tconst isChanging = state !== nextState;\n\n\t\t// If not intending to update dirty flag, return early and avoid clone.\n\t\tif ( ! isChanging && ! isReset ) {\n\t\t\treturn state;\n\t\t}\n\n\t\t// Avoid mutating state, unless it's already changing by original\n\t\t// reducer and not initial.\n\t\tif ( ! isChanging || state === undefined ) {\n\t\t\tnextState = { ...nextState };\n\t\t}\n\n\t\tconst isIgnored = includes( options.ignoreTypes, action.type );\n\n\t\tif ( isIgnored ) {\n\t\t\t// Preserve the original value if ignored.\n\t\t\tnextState.isDirty = state.isDirty;\n\t\t} else {\n\t\t\tnextState.isDirty = ! isReset && isChanging;\n\t\t}\n\n\t\treturn nextState;\n\t};\n};\n\nexport default withChangeDetection;\n"]}