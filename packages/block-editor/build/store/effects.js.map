{"version":3,"sources":["@wordpress/block-editor/src/store/effects.js"],"names":["validateBlocksToTemplate","action","store","state","getState","template","templateLock","isBlocksValidToTemplate","blocks","ensureDefaultBlock","MERGE_BLOCKS","dispatch","firstBlockClientId","secondBlockClientId","blockA","blockType","name","merge","clientId","blockB","blocksWithTheSameType","length","updatedAttributes","attributes","slice","RESET_BLOCKS","REPLACE_BLOCKS","MULTI_SELECT","blockCount","SYNCHRONIZE_TEMPLATE","updatedBlockList"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { speak } from '@wordpress/a11y';\nimport {\n\tgetBlockType,\n\tdoBlocksMatchTemplate,\n\tswitchToBlockType,\n\tsynchronizeBlocksWithTemplate,\n} from '@wordpress/blocks';\nimport { _n, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport {\n\treplaceBlocks,\n\tselectBlock,\n\tsetTemplateValidity,\n\tinsertDefaultBlock,\n\tresetBlocks,\n} from './actions';\nimport {\n\tgetBlock,\n\tgetBlocks,\n\tgetSelectedBlockCount,\n\tgetBlockCount,\n\tgetTemplateLock,\n\tgetTemplate,\n\tisValidTemplate,\n} from './selectors';\n\n/**\n * Block validity is a function of blocks state (at the point of a\n * reset) and the template setting. As a compromise to its placement\n * across distinct parts of state, it is implemented here as a side-\n * effect of the block reset action.\n *\n * @param {Object} action RESET_BLOCKS action.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} New validity set action if validity has changed.\n */\nexport function validateBlocksToTemplate( action, store ) {\n\tconst state = store.getState();\n\tconst template = getTemplate( state );\n\tconst templateLock = getTemplateLock( state );\n\n\t// Unlocked templates are considered always valid because they act\n\t// as default values only.\n\tconst isBlocksValidToTemplate = (\n\t\t! template ||\n\t\ttemplateLock !== 'all' ||\n\t\tdoBlocksMatchTemplate( action.blocks, template )\n\t);\n\n\t// Update if validity has changed.\n\tif ( isBlocksValidToTemplate !== isValidTemplate( state ) ) {\n\t\treturn setTemplateValidity( isBlocksValidToTemplate );\n\t}\n}\n\n/**\n * Effect handler which will return a default block insertion action if there\n * are no other blocks at the root of the editor. This is expected to be used\n * in actions which may result in no blocks remaining in the editor (removal,\n * replacement, etc).\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Default block insert action, if no other blocks exist.\n */\nexport function ensureDefaultBlock( action, store ) {\n\tif ( ! getBlockCount( store.getState() ) ) {\n\t\treturn insertDefaultBlock();\n\t}\n}\n\nexport default {\n\tMERGE_BLOCKS( action, store ) {\n\t\tconst { dispatch } = store;\n\t\tconst state = store.getState();\n\t\tconst [ firstBlockClientId, secondBlockClientId ] = action.blocks;\n\t\tconst blockA = getBlock( state, firstBlockClientId );\n\t\tconst blockType = getBlockType( blockA.name );\n\n\t\t// Only focus the previous block if it's not mergeable\n\t\tif ( ! blockType.merge ) {\n\t\t\tdispatch( selectBlock( blockA.clientId ) );\n\t\t\treturn;\n\t\t}\n\n\t\t// We can only merge blocks with similar types\n\t\t// thus, we transform the block to merge first\n\t\tconst blockB = getBlock( state, secondBlockClientId );\n\t\tconst blocksWithTheSameType = blockA.name === blockB.name ?\n\t\t\t[ blockB ] :\n\t\t\tswitchToBlockType( blockB, blockA.name );\n\n\t\t// If the block types can not match, do nothing\n\t\tif ( ! blocksWithTheSameType || ! blocksWithTheSameType.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calling the merge to update the attributes and remove the block to be merged\n\t\tconst updatedAttributes = blockType.merge(\n\t\t\tblockA.attributes,\n\t\t\tblocksWithTheSameType[ 0 ].attributes\n\t\t);\n\n\t\tdispatch( selectBlock( blockA.clientId, -1 ) );\n\t\tdispatch( replaceBlocks(\n\t\t\t[ blockA.clientId, blockB.clientId ],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t...blockA,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t...blockA.attributes,\n\t\t\t\t\t\t...updatedAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...blocksWithTheSameType.slice( 1 ),\n\t\t\t]\n\t\t) );\n\t},\n\tRESET_BLOCKS: [\n\t\tvalidateBlocksToTemplate,\n\t],\n\tREPLACE_BLOCKS: [\n\t\tensureDefaultBlock,\n\t],\n\tMULTI_SELECT: ( action, { getState } ) => {\n\t\tconst blockCount = getSelectedBlockCount( getState() );\n\n\t\t/* translators: %s: number of selected blocks */\n\t\tspeak( sprintf( _n( '%s block selected.', '%s blocks selected.', blockCount ), blockCount ), 'assertive' );\n\t},\n\tSYNCHRONIZE_TEMPLATE( action, { getState } ) {\n\t\tconst state = getState();\n\t\tconst blocks = getBlocks( state );\n\t\tconst template = getTemplate( state );\n\t\tconst updatedBlockList = synchronizeBlocksWithTemplate( blocks, template );\n\n\t\treturn resetBlocks( updatedBlockList );\n\t},\n};\n"]}