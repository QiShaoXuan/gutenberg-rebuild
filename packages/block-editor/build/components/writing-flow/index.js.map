{"version":3,"sources":["@wordpress/block-editor/src/components/writing-flow/index.js"],"names":["window","getSelection","isTabbableTextField","isTextField","focus","tabbable","isTabbableIndex","isNavigationCandidate","element","keyCode","hasModifier","isVertical","UP","DOWN","tagName","WritingFlow","arguments","onKeyDown","bind","bindContainer","clearVerticalRect","focusLastTextField","verticalRect","ref","container","target","isReverse","focusableNodes","focusable","find","slice","indexOf","isTabCandidate","node","i","array","contains","offset","nextNode","props","selectedBlockClientId","selectionStartClientId","selectionBeforeEndClientId","selectionAfterEndClientId","nextSelectionEndClientId","onMultiSelect","selectedFirstClientId","selectedLastClientId","focusedBlockClientId","onSelectBlock","closestTabbable","getClosestTabbable","event","hasMultiSelection","blocks","isUp","isDown","isLeft","LEFT","isRight","RIGHT","isHorizontal","isNav","isShift","shiftKey","ctrlKey","altKey","metaKey","isNavEdge","isVerticalEdge","isHorizontalEdge","isKeyboardEvent","primary","isEntirelySelected","isContentEditable","preventDefault","nativeEvent","defaultPrevented","isTabbableEdge","expandSelection","moveSelection","isCollapsed","children","Component","select","getSelectedBlockClientId","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getPreviousBlockClientId","getNextBlockClientId","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","getBlockOrder","selectionEndClientId","dispatch","multiSelect","selectBlock"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { overEvery, find, findLast, reverse, first, last } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component } from '@wordpress/element';\nimport {\n\tcomputeCaretRect,\n\tfocus,\n\tisHorizontalEdge,\n\tisTextField,\n\tisVerticalEdge,\n\tplaceCaretAtHorizontalEdge,\n\tplaceCaretAtVerticalEdge,\n\tisEntirelySelected,\n} from '@wordpress/dom';\nimport { UP, DOWN, LEFT, RIGHT, isKeyboardEvent } from '@wordpress/keycodes';\nimport { withSelect, withDispatch } from '@wordpress/data';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport {\n\tisBlockFocusStop,\n\tisInSameBlock,\n\thasInnerBlocksContext,\n} from '../../utils/dom';\n\n/**\n * Browser constants\n */\n\nconst { getSelection } = window;\n\n/**\n * Given an element, returns true if the element is a tabbable text field, or\n * false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is a tabbable text field.\n */\nconst isTabbableTextField = overEvery( [\n\tisTextField,\n\tfocus.tabbable.isTabbableIndex,\n] );\n\n/**\n * Returns true if the element should consider edge navigation upon a keyboard\n * event of the given directional key code, or false otherwise.\n *\n * @param {Element} element     HTML element to test.\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\n * @param {boolean} hasModifier Whether a modifier is pressed.\n *\n * @return {boolean} Whether element should consider edge navigation.\n */\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\n\tconst isVertical = ( keyCode === UP || keyCode === DOWN );\n\n\t// Currently, all elements support unmodified vertical navigation.\n\tif ( isVertical && ! hasModifier ) {\n\t\treturn true;\n\t}\n\n\t// Native inputs should not navigate horizontally.\n\tconst { tagName } = element;\n\treturn tagName !== 'INPUT' && tagName !== 'TEXTAREA';\n}\n\nclass WritingFlow extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.onKeyDown = this.onKeyDown.bind( this );\n\t\tthis.bindContainer = this.bindContainer.bind( this );\n\t\tthis.clearVerticalRect = this.clearVerticalRect.bind( this );\n\t\tthis.focusLastTextField = this.focusLastTextField.bind( this );\n\n\t\t/**\n\t\t * Here a rectangle is stored while moving the caret vertically so\n\t\t * vertical position of the start position can be restored.\n\t\t * This is to recreate browser behaviour across blocks.\n\t\t *\n\t\t * @type {?DOMRect}\n\t\t */\n\t\tthis.verticalRect = null;\n\t}\n\n\tbindContainer( ref ) {\n\t\tthis.container = ref;\n\t}\n\n\tclearVerticalRect() {\n\t\tthis.verticalRect = null;\n\t}\n\n\t/**\n\t * Returns the optimal tab target from the given focused element in the\n\t * desired direction. A preference is made toward text fields, falling back\n\t * to the block focus stop if no other candidates exist for the block.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {?Element} Optimal tab target, if one exists.\n\t */\n\tgetClosestTabbable( target, isReverse ) {\n\t\t// Since the current focus target is not guaranteed to be a text field,\n\t\t// find all focusables. Tabbability is considered later.\n\t\tlet focusableNodes = focus.focusable.find( this.container );\n\n\t\tif ( isReverse ) {\n\t\t\tfocusableNodes = reverse( focusableNodes );\n\t\t}\n\n\t\t// Consider as candidates those focusables after the current target.\n\t\t// It's assumed this can only be reached if the target is focusable\n\t\t// (on its keydown event), so no need to verify it exists in the set.\n\t\tfocusableNodes = focusableNodes.slice( focusableNodes.indexOf( target ) + 1 );\n\n\t\tfunction isTabCandidate( node, i, array ) {\n\t\t\t// Not a candidate if the node is not tabbable.\n\t\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prefer text fields...\n\t\t\tif ( isTextField( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// ...but settle for block focus stop.\n\t\t\tif ( ! isBlockFocusStop( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If element contains inner blocks, stop immediately at its focus\n\t\t\t// wrapper.\n\t\t\tif ( hasInnerBlocksContext( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// If navigating out of a block (in reverse), don't consider its\n\t\t\t// block focus stop.\n\t\t\tif ( node.contains( target ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// In case of block focus stop, check to see if there's a better\n\t\t\t// text field candidate within.\n\t\t\tfor ( let offset = 1, nextNode; ( nextNode = array[ i + offset ] ); offset++ ) {\n\t\t\t\t// Abort if no longer testing descendents of focus stop.\n\t\t\t\tif ( ! node.contains( nextNode ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Apply same tests by recursion. This is important to consider\n\t\t\t\t// nestable blocks where we don't want to settle for the inner\n\t\t\t\t// block focus stop.\n\t\t\t\tif ( isTabCandidate( nextNode, i + offset, array ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn find( focusableNodes, isTabCandidate );\n\t}\n\n\texpandSelection( isReverse ) {\n\t\tconst {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t} = this.props;\n\n\t\tconst nextSelectionEndClientId = isReverse ?\n\t\t\tselectionBeforeEndClientId :\n\t\t\tselectionAfterEndClientId;\n\n\t\tif ( nextSelectionEndClientId ) {\n\t\t\tthis.props.onMultiSelect(\n\t\t\t\tselectionStartClientId || selectedBlockClientId,\n\t\t\t\tnextSelectionEndClientId\n\t\t\t);\n\t\t}\n\t}\n\n\tmoveSelection( isReverse ) {\n\t\tconst { selectedFirstClientId, selectedLastClientId } = this.props;\n\n\t\tconst focusedBlockClientId = isReverse ? selectedFirstClientId : selectedLastClientId;\n\n\t\tif ( focusedBlockClientId ) {\n\t\t\tthis.props.onSelectBlock( focusedBlockClientId );\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the given target field is the last in its block which\n\t * can be considered for tab transition. For example, in a block with two\n\t * text fields, this would return true when reversing from the first of the\n\t * two fields, but false when reversing from the second.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {boolean} Whether field is at edge for tab transition.\n\t */\n\tisTabbableEdge( target, isReverse ) {\n\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\t\treturn ! closestTabbable || ! isInSameBlock( target, closestTabbable );\n\t}\n\n\tonKeyDown( event ) {\n\t\tconst {\n\t\t\thasMultiSelection,\n\t\t\tonMultiSelect,\n\t\t\tblocks,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t} = this.props;\n\n\t\tconst { keyCode, target } = event;\n\t\tconst isUp = keyCode === UP;\n\t\tconst isDown = keyCode === DOWN;\n\t\tconst isLeft = keyCode === LEFT;\n\t\tconst isRight = keyCode === RIGHT;\n\t\tconst isReverse = isUp || isLeft;\n\t\tconst isHorizontal = isLeft || isRight;\n\t\tconst isVertical = isUp || isDown;\n\t\tconst isNav = isHorizontal || isVertical;\n\t\tconst isShift = event.shiftKey;\n\t\tconst hasModifier = isShift || event.ctrlKey || event.altKey || event.metaKey;\n\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\n\n\t\t// This logic inside this condition needs to be checked before\n\t\t// the check for event.nativeEvent.defaultPrevented.\n\t\t// The logic handles meta+a keypress and this event is default prevented\n\t\t// by RichText.\n\t\tif ( ! isNav ) {\n\t\t\t// Set immediately before the meta+a combination can be pressed.\n\t\t\tif ( isKeyboardEvent.primary( event ) ) {\n\t\t\t\tthis.isEntirelySelected = isEntirelySelected( target );\n\t\t\t}\n\n\t\t\tif ( isKeyboardEvent.primary( event, 'a' ) ) {\n\t\t\t\t// When the target is contentEditable, selection will already\n\t\t\t\t// have been set by the browser earlier in this call stack. We\n\t\t\t\t// need check the previous result, otherwise all blocks will be\n\t\t\t\t// selected right away.\n\t\t\t\tif ( target.isContentEditable ? this.isEntirelySelected : isEntirelySelected( target ) ) {\n\t\t\t\t\tonMultiSelect( first( blocks ), last( blocks ) );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// After pressing primary + A we can assume isEntirelySelected is true.\n\t\t\t\t// Calling right away isEntirelySelected after primary + A may still return false on some browsers.\n\t\t\t\tthis.isEntirelySelected = true;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if navigation has already been handled (e.g. RichText inline\n\t\t// boundaries).\n\t\tif ( event.nativeEvent.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if our current target is not a candidate for navigation (e.g.\n\t\t// preserve native input behaviors).\n\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! isVertical ) {\n\t\t\tthis.verticalRect = null;\n\t\t} else if ( ! this.verticalRect ) {\n\t\t\tthis.verticalRect = computeCaretRect( target );\n\t\t}\n\n\t\tif ( isShift ) {\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t// Ensure that there is a target block.\n\t\t\t\t\t( isReverse && selectionBeforeEndClientId ) ||\n\t\t\t\t\t( ! isReverse && selectionAfterEndClientId )\n\t\t\t\t) && (\n\t\t\t\t\thasMultiSelection || (\n\t\t\t\t\t\tthis.isTabbableEdge( target, isReverse ) &&\n\t\t\t\t\t\tisNavEdge( target, isReverse )\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Shift key is down, and there is multi selection or we're at\n\t\t\t\t// the end of the current block.\n\t\t\t\tthis.expandSelection( isReverse );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( hasMultiSelection ) {\n\t\t\t// Moving from block multi-selection to single block selection\n\t\t\tthis.moveSelection( isReverse );\n\t\t\tevent.preventDefault();\n\t\t} else if ( isVertical && isVerticalEdge( target, isReverse ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\n\t\t\tif ( closestTabbable ) {\n\t\t\t\tplaceCaretAtVerticalEdge( closestTabbable, isReverse, this.verticalRect );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( isHorizontal && getSelection().isCollapsed && isHorizontalEdge( target, isReverse ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverse );\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Sets focus to the end of the last tabbable text field, if one exists.\n\t */\n\tfocusLastTextField() {\n\t\tconst focusableNodes = focus.focusable.find( this.container );\n\t\tconst target = findLast( focusableNodes, isTabbableTextField );\n\t\tif ( target ) {\n\t\t\tplaceCaretAtHorizontalEdge( target, true );\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { children } = this.props;\n\n\t\t// Disable reason: Wrapper itself is non-interactive, but must capture\n\t\t// bubbling events from children to determine focus transition intents.\n\t\t/* eslint-disable jsx-a11y/no-static-element-interactions */\n\t\treturn (\n\t\t\t<div className=\"editor-writing-flow block-editor-writing-flow\">\n\t\t\t\t<div\n\t\t\t\t\tref={ this.bindContainer }\n\t\t\t\t\tonKeyDown={ this.onKeyDown }\n\t\t\t\t\tonMouseDown={ this.clearVerticalRect }\n\t\t\t\t>\n\t\t\t\t\t{ children }\n\t\t\t\t</div>\n\t\t\t\t<div\n\t\t\t\t\taria-hidden\n\t\t\t\t\ttabIndex={ -1 }\n\t\t\t\t\tonClick={ this.focusLastTextField }\n\t\t\t\t\tclassName=\"wp-block editor-writing-flow__click-redirect block-editor-writing-flow__click-redirect\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t\t/* eslint-disable jsx-a11y/no-static-element-interactions */\n\t}\n}\n\nexport default compose( [\n\twithSelect( ( select ) => {\n\t\tconst {\n\t\t\tgetSelectedBlockClientId,\n\t\t\tgetMultiSelectedBlocksStartClientId,\n\t\t\tgetMultiSelectedBlocksEndClientId,\n\t\t\tgetPreviousBlockClientId,\n\t\t\tgetNextBlockClientId,\n\t\t\tgetFirstMultiSelectedBlockClientId,\n\t\t\tgetLastMultiSelectedBlockClientId,\n\t\t\thasMultiSelection,\n\t\t\tgetBlockOrder,\n\t\t} = select( 'core/block-editor' );\n\n\t\tconst selectedBlockClientId = getSelectedBlockClientId();\n\t\tconst selectionStartClientId = getMultiSelectedBlocksStartClientId();\n\t\tconst selectionEndClientId = getMultiSelectedBlocksEndClientId();\n\n\t\treturn {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId: getPreviousBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectionAfterEndClientId: getNextBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectedFirstClientId: getFirstMultiSelectedBlockClientId(),\n\t\t\tselectedLastClientId: getLastMultiSelectedBlockClientId(),\n\t\t\thasMultiSelection: hasMultiSelection(),\n\t\t\tblocks: getBlockOrder(),\n\t\t};\n\t} ),\n\twithDispatch( ( dispatch ) => {\n\t\tconst { multiSelect, selectBlock } = dispatch( 'core/block-editor' );\n\t\treturn {\n\t\t\tonMultiSelect: multiSelect,\n\t\t\tonSelectBlock: selectBlock,\n\t\t};\n\t} ),\n] )( WritingFlow );\n"]}