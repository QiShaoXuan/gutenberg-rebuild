{"version":3,"sources":["@wordpress/block-editor/src/store/selectors.js"],"names":["castArray","flatMap","first","get","includes","isArray","isBoolean","last","map","orderBy","reduce","some","createSelector","getBlockType","getBlockTypes","hasBlockSupport","hasChildBlocksWithInserterSupport","INSERTER_UTILITY_HIGH","INSERTER_UTILITY_MEDIUM","INSERTER_UTILITY_LOW","INSERTER_UTILITY_NONE","MILLISECONDS_PER_HOUR","MILLISECONDS_PER_DAY","MILLISECONDS_PER_WEEK","EMPTY_ARRAY","EMPTY_OBJECT","getBlockDependantsCacheBust","state","clientId","getBlockOrder","innerBlockClientId","getBlock","getBlockName","block","blocks","byClientId","name","isBlockValid","isValid","getBlockAttributes","attributes","type","result","value","key","source","getPostMeta","meta","innerBlocks","getBlocks","getDependants","__unstableGetBlockWithoutInnerBlocks","rootClientId","order","getClientIdsOfDescendants","clientIds","descendants","getClientIdsWithDescendants","topLevelIds","getGlobalBlockCount","blockName","length","count","getBlocksByClientId","getBlockCount","getBlockSelectionStart","blockSelection","start","getBlockSelectionEnd","end","getSelectedBlockCount","multiSelectedBlockCount","getMultiSelectedBlockClientIds","hasSelectedBlock","getSelectedBlockClientId","getSelectedBlock","getBlockRootClientId","getBlockHierarchyRootClientId","current","getAdjacentBlockClientId","startClientId","modifier","undefined","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","orderSet","index","indexOf","nextIndex","getPreviousBlockClientId","getNextBlockClientId","getSelectedBlocksInitialCaretPosition","initialPosition","getSelectedBlockClientIds","blockOrder","startIndex","endIndex","slice","getMultiSelectedBlocks","multiSelectedBlockClientIds","isAncestorOf","possibleAncestorId","possibleDescendentId","idToCheck","isFirstMultiSelectedBlock","isBlockMultiSelected","isAncestorMultiSelected","ancestorClientId","isMultiSelected","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getBlockIndex","isBlockSelected","hasSelectedInnerBlock","deep","innerClientId","isBlockWithinSelection","hasMultiSelection","isMultiSelecting","isSelectionEnabled","isEnabled","getBlockMode","blocksMode","isTyping","isCaretWithinFormattedText","getBlockInsertionPoint","insertionPoint","isBlockInsertionPointVisible","isValidTemplate","template","getTemplate","settings","getTemplateLock","templateLock","blockListSettings","getBlockListSettings","canInsertBlockTypeUnmemoized","checkAllowList","list","item","defaultResult","blockType","getSettings","allowedBlockTypes","isBlockAllowedInEditor","isLocked","parentBlockListSettings","parentAllowedBlocks","hasParentAllowedBlock","blockAllowedParentBlocks","parent","parentName","hasBlockAllowedParent","canInsertBlockType","getInsertUsage","id","preferences","insertUsage","canIncludeBlockTypeInInserter","canIncludeReusableBlockInInserter","reusableBlock","referencedBlockName","referencedBlockType","getInserterItems","calculateUtility","category","isContextual","calculateFrecency","time","duration","Date","now","buildBlockTypeInserterItem","isDisabled","initialAttributes","title","icon","keywords","utility","frecency","buildReusableBlockInserterItem","ref","blockTypeInserterItems","filter","reusableBlockInserterItems","getReusableBlocks","hasInserterItems","hasBlockType","hasReusableBlock","isLastBlockChangePersistent","isPersistentChange"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport {\n\tcastArray,\n\tflatMap,\n\tfirst,\n\tget,\n\tincludes,\n\tisArray,\n\tisBoolean,\n\tlast,\n\tmap,\n\torderBy,\n\treduce,\n\tsome,\n} from 'lodash';\nimport createSelector from 'rememo';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tgetBlockType,\n\tgetBlockTypes,\n\thasBlockSupport,\n\thasChildBlocksWithInserterSupport,\n} from '@wordpress/blocks';\n\n/***\n * Module constants\n */\nexport const INSERTER_UTILITY_HIGH = 3;\nexport const INSERTER_UTILITY_MEDIUM = 2;\nexport const INSERTER_UTILITY_LOW = 1;\nexport const INSERTER_UTILITY_NONE = 0;\nconst MILLISECONDS_PER_HOUR = 3600 * 1000;\nconst MILLISECONDS_PER_DAY = 24 * 3600 * 1000;\nconst MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Shared reference to an empty object for cases where it is important to avoid\n * returning a new object reference on every invocation.\n *\n * @type {Object}\n */\nconst EMPTY_OBJECT = {};\n\n/**\n * Returns a new reference when the inner blocks of a given block client ID\n * change. This is used exclusively as a memoized selector dependant, relying\n * on this selector's shared return value and recursively those of its inner\n * blocks defined as dependencies. This abuses mechanics of the selector\n * memoization to return from the original selector function only when\n * dependants change.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {*} A value whose reference will change only when inner blocks of\n *             the given block client ID change.\n */\nexport const getBlockDependantsCacheBust = createSelector(\n\t() => [],\n\t( state, clientId ) => map(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerBlockClientId ) => getBlock( state, innerBlockClientId ),\n\t),\n);\n\n/**\n * Returns a block's name given its client ID, or null if no block exists with\n * the client ID.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {string} Block name.\n */\nexport function getBlockName( state, clientId ) {\n\tconst block = state.blocks.byClientId[ clientId ];\n\treturn block ? block.name : null;\n}\n\n/**\n * Returns whether a block is valid or not.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Is Valid.\n */\nexport function isBlockValid( state, clientId ) {\n\tconst block = state.blocks.byClientId[ clientId ];\n\treturn !! block && block.isValid;\n}\n\n/**\n * Returns a block's attributes given its client ID, or null if no block exists with\n * the client ID.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object?} Block attributes.\n */\nexport const getBlockAttributes = createSelector(\n\t( state, clientId ) => {\n\t\tconst block = state.blocks.byClientId[ clientId ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet attributes = state.blocks.attributes[ clientId ];\n\n\t\t// Inject custom source attribute values.\n\t\t//\n\t\t// TODO: Create generic external sourcing pattern, not explicitly\n\t\t// targeting meta attributes.\n\t\tconst type = getBlockType( block.name );\n\t\tif ( type ) {\n\t\t\tattributes = reduce( type.attributes, ( result, value, key ) => {\n\t\t\t\tif ( value.source === 'meta' ) {\n\t\t\t\t\tif ( result === attributes ) {\n\t\t\t\t\t\tresult = { ...result };\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[ key ] = getPostMeta( state, value.meta );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, attributes );\n\t\t}\n\n\t\treturn attributes;\n\t},\n\t( state, clientId ) => [\n\t\tstate.blocks.byClientId[ clientId ],\n\t\tstate.blocks.attributes[ clientId ],\n\t\tgetPostMeta( state ),\n\t]\n);\n\n/**\n * Returns a block given its client ID. This is a parsed copy of the block,\n * containing its `blockName`, `clientId`, and current `attributes` state. This\n * is not the block's registration settings, which must be retrieved from the\n * blocks module registration store.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Parsed block object.\n */\nexport const getBlock = createSelector(\n\t( state, clientId ) => {\n\t\tconst block = state.blocks.byClientId[ clientId ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tattributes: getBlockAttributes( state, clientId ),\n\t\t\tinnerBlocks: getBlocks( state, clientId ),\n\t\t};\n\t},\n\t( state, clientId ) => [\n\t\t...getBlockAttributes.getDependants( state, clientId ),\n\t\tgetBlockDependantsCacheBust( state, clientId ),\n\t]\n);\n\nexport const __unstableGetBlockWithoutInnerBlocks = createSelector(\n\t( state, clientId ) => {\n\t\tconst block = state.blocks.byClientId[ clientId ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tattributes: getBlockAttributes( state, clientId ),\n\t\t};\n\t},\n\t( state, clientId ) => [\n\t\tstate.blocks.byClientId[ clientId ],\n\t\t...getBlockAttributes.getDependants( state, clientId ),\n\t]\n);\n\n/**\n * Returns all block objects for the current post being edited as an array in\n * the order they appear in the post.\n *\n * Note: It's important to memoize this selector to avoid return a new instance\n * on each call\n *\n * @param {Object}  state        Editor state.\n * @param {?String} rootClientId Optional root client ID of block list.\n *\n * @return {Object[]} Post blocks.\n */\nexport const getBlocks = createSelector(\n\t( state, rootClientId ) => {\n\t\treturn map(\n\t\t\tgetBlockOrder( state, rootClientId ),\n\t\t\t( clientId ) => getBlock( state, clientId )\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.blocks.byClientId,\n\t\tstate.blocks.order,\n\t\tstate.blocks.attributes,\n\t]\n);\n\n/**\n * Returns an array containing the clientIds of all descendants\n * of the blocks given.\n *\n * @param {Object} state Global application state.\n * @param {Array} clientIds Array of blocks to inspect.\n *\n * @return {Array} ids of descendants.\n */\nexport const getClientIdsOfDescendants = ( state, clientIds ) => flatMap( clientIds, ( clientId ) => {\n\tconst descendants = getBlockOrder( state, clientId );\n\treturn [ ...descendants, ...getClientIdsOfDescendants( state, descendants ) ];\n} );\n\n/**\n * Returns an array containing the clientIds of the top-level blocks\n * and their descendants of any depth (for nested blocks).\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} ids of top-level and descendant blocks.\n */\nexport const getClientIdsWithDescendants = createSelector(\n\t( state ) => {\n\t\tconst topLevelIds = getBlockOrder( state );\n\t\treturn [ ...topLevelIds, ...getClientIdsOfDescendants( state, topLevelIds ) ];\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t]\n);\n\n/**\n * Returns the total number of blocks, or the total number of blocks with a specific name in a post.\n * The number returned includes nested blocks.\n *\n * @param {Object}  state     Global application state.\n * @param {?String} blockName Optional block name, if specified only blocks of that type will be counted.\n *\n * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.\n */\nexport const getGlobalBlockCount = createSelector(\n\t( state, blockName ) => {\n\t\tconst clientIds = getClientIdsWithDescendants( state );\n\t\tif ( ! blockName ) {\n\t\t\treturn clientIds.length;\n\t\t}\n\t\treturn reduce( clientIds, ( count, clientId ) => {\n\t\t\tconst block = state.blocks.byClientId[ clientId ];\n\t\t\treturn block.name === blockName ? count + 1 : count;\n\t\t}, 0 );\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t\tstate.blocks.byClientId,\n\t]\n);\n\n/**\n * Given an array of block client IDs, returns the corresponding array of block\n * objects.\n *\n * @param {Object}   state     Editor state.\n * @param {string[]} clientIds Client IDs for which blocks are to be returned.\n *\n * @return {WPBlock[]} Block objects.\n */\nexport const getBlocksByClientId = createSelector(\n\t( state, clientIds ) => map(\n\t\tcastArray( clientIds ),\n\t\t( clientId ) => getBlock( state, clientId )\n\t),\n\t( state ) => [\n\t\tgetPostMeta( state ),\n\t\tstate.blocks.byClientId,\n\t\tstate.blocks.order,\n\t\tstate.blocks.attributes,\n\t]\n);\n\n/**\n * Returns the number of blocks currently present in the post.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Number of blocks in the post.\n */\nexport function getBlockCount( state, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).length;\n}\n\n/**\n * Returns the current block selection start. This value may be null, and it\n * may represent either a singular block selection or multi-selection start.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection start.\n */\nexport function getBlockSelectionStart( state ) {\n\treturn state.blockSelection.start;\n}\n\n/**\n * Returns the current block selection end. This value may be null, and it\n * may represent either a singular block selection or multi-selection end.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection end.\n */\nexport function getBlockSelectionEnd( state ) {\n\treturn state.blockSelection.end;\n}\n\n/**\n * Returns the number of blocks currently selected in the post.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of blocks selected in the post.\n */\nexport function getSelectedBlockCount( state ) {\n\tconst multiSelectedBlockCount = getMultiSelectedBlockClientIds( state ).length;\n\n\tif ( multiSelectedBlockCount ) {\n\t\treturn multiSelectedBlockCount;\n\t}\n\n\treturn state.blockSelection.start ? 1 : 0;\n}\n\n/**\n * Returns true if there is a single selected block, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether a single block is selected.\n */\nexport function hasSelectedBlock( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn !! start && start === end;\n}\n\n/**\n * Returns the currently selected block client ID, or null if there is no\n * selected block.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Selected block client ID.\n */\nexport function getSelectedBlockClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\t// We need to check the block exists because the current blockSelection\n\t// reducer doesn't take into account when blocks are reset via undo. To be\n\t// removed when that's fixed.\n\treturn start && start === end && !! state.blocks.byClientId[ start ] ? start : null;\n}\n\n/**\n * Returns the currently selected block, or null if there is no selected block.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlock( state ) {\n\tconst clientId = getSelectedBlockClientId( state );\n\treturn clientId ? getBlock( state, clientId ) : null;\n}\n\n/**\n * Given a block client ID, returns the root block from which the block is\n * nested, an empty string for top-level blocks, or null if the block does not\n * exist.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {?string} Root client ID, if exists\n */\nexport const getBlockRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tconst { order } = state.blocks;\n\n\t\tfor ( const rootClientId in order ) {\n\t\t\tif ( includes( order[ rootClientId ], clientId ) ) {\n\t\t\t\treturn rootClientId;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t]\n);\n\n/**\n * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {string} Root client ID\n */\nexport const getBlockHierarchyRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tlet rootClientId = clientId;\n\t\tlet current = clientId;\n\t\twhile ( rootClientId ) {\n\t\t\tcurrent = rootClientId;\n\t\t\trootClientId = getBlockRootClientId( state, current );\n\t\t}\n\n\t\treturn current;\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t]\n);\n\n/**\n * Returns the client ID of the block adjacent one at the given reference\n * startClientId and modifier directionality. Defaults start startClientId to\n * the selected block, and direction as next block. Returns null if there is no\n * adjacent block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n * @param {?number} modifier      Directionality multiplier (1 next, -1\n *                                previous).\n *\n * @return {?string} Return the client ID of the block, or null if none exists.\n */\nexport function getAdjacentBlockClientId( state, startClientId, modifier = 1 ) {\n\t// Default to selected block.\n\tif ( startClientId === undefined ) {\n\t\tstartClientId = getSelectedBlockClientId( state );\n\t}\n\n\t// Try multi-selection starting at extent based on modifier.\n\tif ( startClientId === undefined ) {\n\t\tif ( modifier < 0 ) {\n\t\t\tstartClientId = getFirstMultiSelectedBlockClientId( state );\n\t\t} else {\n\t\t\tstartClientId = getLastMultiSelectedBlockClientId( state );\n\t\t}\n\t}\n\n\t// Validate working start client ID.\n\tif ( ! startClientId ) {\n\t\treturn null;\n\t}\n\n\t// Retrieve start block root client ID, being careful to allow the falsey\n\t// empty string top-level root by explicitly testing against null.\n\tconst rootClientId = getBlockRootClientId( state, startClientId );\n\tif ( rootClientId === null ) {\n\t\treturn null;\n\t}\n\n\tconst { order } = state.blocks;\n\tconst orderSet = order[ rootClientId ];\n\tconst index = orderSet.indexOf( startClientId );\n\tconst nextIndex = ( index + ( 1 * modifier ) );\n\n\t// Block was first in set and we're attempting to get previous.\n\tif ( nextIndex < 0 ) {\n\t\treturn null;\n\t}\n\n\t// Block was last in set and we're attempting to get next.\n\tif ( nextIndex === orderSet.length ) {\n\t\treturn null;\n\t}\n\n\t// Assume incremented index is within the set.\n\treturn orderSet[ nextIndex ];\n}\n\n/**\n * Returns the previous block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no previous\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getPreviousBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, -1 );\n}\n\n/**\n * Returns the next block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no next\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getNextBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, 1 );\n}\n\n/**\n * Returns the initial caret position for the selected block.\n * This position is to used to position the caret properly when the selected block changes.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlocksInitialCaretPosition( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start !== end || ! start ) {\n\t\treturn null;\n\t}\n\n\treturn state.blockSelection.initialPosition;\n}\n\n/**\n * Returns the current selection set of block client IDs (multiselection or single selection).\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block client IDs.\n */\nexport const getSelectedBlockClientIds = createSelector(\n\t( state ) => {\n\t\tconst { start, end } = state.blockSelection;\n\t\tif ( start === null || end === null ) {\n\t\t\treturn EMPTY_ARRAY;\n\t\t}\n\n\t\tif ( start === end ) {\n\t\t\treturn [ start ];\n\t\t}\n\n\t\t// Retrieve root client ID to aid in retrieving relevant nested block\n\t\t// order, being careful to allow the falsey empty string top-level root\n\t\t// by explicitly testing against null.\n\t\tconst rootClientId = getBlockRootClientId( state, start );\n\t\tif ( rootClientId === null ) {\n\t\t\treturn EMPTY_ARRAY;\n\t\t}\n\n\t\tconst blockOrder = getBlockOrder( state, rootClientId );\n\t\tconst startIndex = blockOrder.indexOf( start );\n\t\tconst endIndex = blockOrder.indexOf( end );\n\n\t\tif ( startIndex > endIndex ) {\n\t\t\treturn blockOrder.slice( endIndex, startIndex + 1 );\n\t\t}\n\n\t\treturn blockOrder.slice( startIndex, endIndex + 1 );\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n\n/**\n * Returns the current multi-selection set of block client IDs, or an empty\n * array if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block client IDs.\n */\nexport function getMultiSelectedBlockClientIds( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn EMPTY_ARRAY;\n\t}\n\n\treturn getSelectedBlockClientIds( state );\n}\n\n/**\n * Returns the current multi-selection set of blocks, or an empty array if\n * there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block objects.\n */\nexport const getMultiSelectedBlocks = createSelector(\n\t( state ) => {\n\t\tconst multiSelectedBlockClientIds = getMultiSelectedBlockClientIds( state );\n\t\tif ( ! multiSelectedBlockClientIds.length ) {\n\t\t\treturn EMPTY_ARRAY;\n\t\t}\n\n\t\treturn multiSelectedBlockClientIds.map( ( clientId ) => getBlock( state, clientId ) );\n\t},\n\t( state ) => [\n\t\t...getSelectedBlockClientIds.getDependants( state ),\n\t\tstate.blocks.byClientId,\n\t\tstate.blocks.order,\n\t\tstate.blocks.attributes,\n\t\tgetPostMeta( state ),\n\t]\n);\n\n/**\n * Returns the client ID of the first block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} First block client ID in the multi-selection set.\n */\nexport function getFirstMultiSelectedBlockClientId( state ) {\n\treturn first( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns the client ID of the last block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Last block client ID in the multi-selection set.\n */\nexport function getLastMultiSelectedBlockClientId( state ) {\n\treturn last( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Checks if possibleAncestorId is an ancestor of possibleDescendentId.\n *\n * @param {Object} state                Editor state.\n * @param {string} possibleAncestorId   Possible ancestor client ID.\n * @param {string} possibleDescendentId Possible descent client ID.\n *\n * @return {boolean} True if possibleAncestorId is an ancestor\n *                   of possibleDescendentId, and false otherwise.\n */\nconst isAncestorOf = createSelector(\n\t( state, possibleAncestorId, possibleDescendentId ) => {\n\t\tlet idToCheck = possibleDescendentId;\n\t\twhile ( possibleAncestorId !== idToCheck && idToCheck ) {\n\t\t\tidToCheck = getBlockRootClientId( state, idToCheck );\n\t\t}\n\t\treturn possibleAncestorId === idToCheck;\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t],\n);\n\n/**\n * Returns true if a multi-selection exists, and the block corresponding to the\n * specified client ID is the first block of the multi-selection set, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is first in multi-selection.\n */\nexport function isFirstMultiSelectedBlock( state, clientId ) {\n\treturn getFirstMultiSelectedBlockClientId( state ) === clientId;\n}\n\n/**\n * Returns true if the client ID occurs within the block multi-selection, or\n * false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is in multi-selection set.\n */\nexport function isBlockMultiSelected( state, clientId ) {\n\treturn getMultiSelectedBlockClientIds( state ).indexOf( clientId ) !== -1;\n}\n\n/**\n * Returns true if an ancestor of the block is multi-selected, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether an ancestor of the block is in multi-selection\n *                   set.\n */\nexport const isAncestorMultiSelected = createSelector(\n\t( state, clientId ) => {\n\t\tlet ancestorClientId = clientId;\n\t\tlet isMultiSelected = false;\n\t\twhile ( ancestorClientId && ! isMultiSelected ) {\n\t\t\tancestorClientId = getBlockRootClientId( state, ancestorClientId );\n\t\t\tisMultiSelected = isBlockMultiSelected( state, ancestorClientId );\n\t\t}\n\t\treturn isMultiSelected;\n\t},\n\t( state ) => [\n\t\tstate.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n/**\n * Returns the client ID of the block which begins the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the first client ID in the selection.\n *\n * @see getFirstMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block beginning multi-selection.\n */\nexport function getMultiSelectedBlocksStartClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn start || null;\n}\n\n/**\n * Returns the client ID of the block which ends the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the last client ID in the selection.\n *\n * @see getLastMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block ending multi-selection.\n */\nexport function getMultiSelectedBlocksEndClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn end || null;\n}\n\n/**\n * Returns an array containing all block client IDs in the editor in the order\n * they appear. Optionally accepts a root client ID of the block list for which\n * the order should be returned, defaulting to the top-level block order.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Array} Ordered client IDs of editor blocks.\n */\nexport function getBlockOrder( state, rootClientId ) {\n\treturn state.blocks.order[ rootClientId || '' ] || EMPTY_ARRAY;\n}\n\n/**\n * Returns the index at which the block corresponding to the specified client\n * ID occurs within the block order, or `-1` if the block does not exist.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  clientId     Block client ID.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Index at which block exists in order.\n */\nexport function getBlockIndex( state, clientId, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).indexOf( clientId );\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected and no multi-selection exists, or false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and multi-selection exists.\n */\nexport function isBlockSelected( state, clientId ) {\n\tconst { start, end } = state.blockSelection;\n\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\treturn start === clientId;\n}\n\n/**\n * Returns true if one of the block's inner blocks is selected.\n *\n * @param {Object}  state    Editor state.\n * @param {string}  clientId Block client ID.\n * @param {boolean} deep     Perform a deep check.\n *\n * @return {boolean} Whether the block as an inner block selected\n */\nexport function hasSelectedInnerBlock( state, clientId, deep = false ) {\n\treturn some(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerClientId ) => (\n\t\t\tisBlockSelected( state, innerClientId ) ||\n\t\t\tisBlockMultiSelected( state, innerClientId ) ||\n\t\t\t( deep && hasSelectedInnerBlock( state, innerClientId, deep ) )\n\t\t)\n\t);\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected but isn't the last of the selected blocks. Here \"last\"\n * refers to the block sequence in the document, _not_ the sequence of\n * multi-selection, which is why `state.blockSelection.end` isn't used.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and not the last in the\n *                   selection.\n */\nexport function isBlockWithinSelection( state, clientId ) {\n\tif ( ! clientId ) {\n\t\treturn false;\n\t}\n\n\tconst clientIds = getMultiSelectedBlockClientIds( state );\n\tconst index = clientIds.indexOf( clientId );\n\treturn index > -1 && index < clientIds.length - 1;\n}\n\n/**\n * Returns true if a multi-selection has been made, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether multi-selection has been made.\n */\nexport function hasMultiSelection( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start !== end;\n}\n\n/**\n * Whether in the process of multi-selecting or not. This flag is only true\n * while the multi-selection is being selected (by mouse move), and is false\n * once the multi-selection has been settled.\n *\n * @see hasMultiSelection\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if multi-selecting, false if not.\n */\nexport function isMultiSelecting( state ) {\n\treturn state.blockSelection.isMultiSelecting;\n}\n\n/**\n * Selector that returns if multi-selection is enabled or not.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.\n */\nexport function isSelectionEnabled( state ) {\n\treturn state.blockSelection.isEnabled;\n}\n\n/**\n * Returns the block's editing mode, defaulting to \"visual\" if not explicitly\n * assigned.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Block editing mode.\n */\nexport function getBlockMode( state, clientId ) {\n\treturn state.blocksMode[ clientId ] || 'visual';\n}\n\n/**\n * Returns true if the user is typing, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether user is typing.\n */\nexport function isTyping( state ) {\n\treturn state.isTyping;\n}\n\n/**\n * Returns true if the caret is within formatted text, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the caret is within formatted text.\n */\nexport function isCaretWithinFormattedText( state ) {\n\treturn state.isCaretWithinFormattedText;\n}\n\n/**\n * Returns the insertion point, the index at which the new inserted block would\n * be placed. Defaults to the last index.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} Insertion point object with `rootClientId`, `index`.\n */\nexport function getBlockInsertionPoint( state ) {\n\tlet rootClientId, index;\n\n\tconst { insertionPoint, blockSelection } = state;\n\tif ( insertionPoint !== null ) {\n\t\treturn insertionPoint;\n\t}\n\n\tconst { end } = blockSelection;\n\tif ( end ) {\n\t\trootClientId = getBlockRootClientId( state, end ) || undefined;\n\t\tindex = getBlockIndex( state, end, rootClientId ) + 1;\n\t} else {\n\t\tindex = getBlockOrder( state ).length;\n\t}\n\n\treturn { rootClientId, index };\n}\n\n/**\n * Returns true if we should show the block insertion point.\n *\n * @param {Object} state Global application state.\n *\n * @return {?boolean} Whether the insertion point is visible or not.\n */\nexport function isBlockInsertionPointVisible( state ) {\n\treturn state.insertionPoint !== null;\n}\n\n/**\n * Returns whether the blocks matches the template or not.\n *\n * @param {boolean} state\n * @return {?boolean} Whether the template is valid or not.\n */\nexport function isValidTemplate( state ) {\n\treturn state.template.isValid;\n}\n\n/**\n * Returns the defined block template\n *\n * @param {boolean} state\n * @return {?Array}        Block Template\n */\nexport function getTemplate( state ) {\n\treturn state.settings.template;\n}\n\n/**\n * Returns the defined block template lock. Optionally accepts a root block\n * client ID as context, otherwise defaulting to the global context.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional block root client ID.\n *\n * @return {?string} Block Template Lock\n */\nexport function getTemplateLock( state, rootClientId ) {\n\tif ( ! rootClientId ) {\n\t\treturn state.settings.templateLock;\n\t}\n\n\tconst blockListSettings = getBlockListSettings( state, rootClientId );\n\tif ( ! blockListSettings ) {\n\t\treturn null;\n\t}\n\n\treturn blockListSettings.templateLock;\n}\n\n/**\n * Determines if the given block type is allowed to be inserted into the block list.\n * This function is not exported and not memoized because using a memoized selector\n * inside another memoized selector is just a waste of time.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be inserted.\n */\nconst canInsertBlockTypeUnmemoized = ( state, blockName, rootClientId = null ) => {\n\tconst checkAllowList = ( list, item, defaultResult = null ) => {\n\t\tif ( isBoolean( list ) ) {\n\t\t\treturn list;\n\t\t}\n\t\tif ( isArray( list ) ) {\n\t\t\treturn includes( list, item );\n\t\t}\n\t\treturn defaultResult;\n\t};\n\n\tconst blockType = getBlockType( blockName );\n\tif ( ! blockType ) {\n\t\treturn false;\n\t}\n\n\tconst { allowedBlockTypes } = getSettings( state );\n\n\tconst isBlockAllowedInEditor = checkAllowList( allowedBlockTypes, blockName, true );\n\tif ( ! isBlockAllowedInEditor ) {\n\t\treturn false;\n\t}\n\n\tconst isLocked = !! getTemplateLock( state, rootClientId );\n\tif ( isLocked ) {\n\t\treturn false;\n\t}\n\n\tconst parentBlockListSettings = getBlockListSettings( state, rootClientId );\n\tconst parentAllowedBlocks = get( parentBlockListSettings, [ 'allowedBlocks' ] );\n\tconst hasParentAllowedBlock = checkAllowList( parentAllowedBlocks, blockName );\n\n\tconst blockAllowedParentBlocks = blockType.parent;\n\tconst parentName = getBlockName( state, rootClientId );\n\tconst hasBlockAllowedParent = checkAllowList( blockAllowedParentBlocks, parentName );\n\n\tif ( hasParentAllowedBlock !== null && hasBlockAllowedParent !== null ) {\n\t\treturn hasParentAllowedBlock || hasBlockAllowedParent;\n\t} else if ( hasParentAllowedBlock !== null ) {\n\t\treturn hasParentAllowedBlock;\n\t} else if ( hasBlockAllowedParent !== null ) {\n\t\treturn hasBlockAllowedParent;\n\t}\n\n\treturn true;\n};\n\n/**\n * Determines if the given block type is allowed to be inserted into the block list.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be inserted.\n */\nexport const canInsertBlockType = createSelector(\n\tcanInsertBlockTypeUnmemoized,\n\t( state, blockName, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.blocks.byClientId[ rootClientId ],\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t],\n);\n\n/**\n * Returns information about how recently and frequently a block has been inserted.\n *\n * @param {Object} state Global application state.\n * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'\n *\n * @return {?{ time: number, count: number }} An object containing `time` which is when the last\n *                                            insert occurred as a UNIX epoch, and `count` which is\n *                                            the number of inserts that have occurred.\n */\nfunction getInsertUsage( state, id ) {\n\treturn get( state.preferences.insertUsage, [ id ], null );\n}\n\n/**\n * Returns whether we can show a block type in the inserter\n *\n * @param {Object} state Global State\n * @param {Object} blockType BlockType\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be shown in the inserter.\n */\nconst canIncludeBlockTypeInInserter = ( state, blockType, rootClientId ) => {\n\tif ( ! hasBlockSupport( blockType, 'inserter', true ) ) {\n\t\treturn false;\n\t}\n\n\treturn canInsertBlockTypeUnmemoized( state, blockType.name, rootClientId );\n};\n\n/**\n * Returns whether we can show a reusable block in the inserter\n *\n * @param {Object} state Global State\n * @param {Object} reusableBlock Reusable block object\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be shown in the inserter.\n */\nconst canIncludeReusableBlockInInserter = ( state, reusableBlock, rootClientId ) => {\n\tif ( ! canInsertBlockTypeUnmemoized( state, 'core/block', rootClientId ) ) {\n\t\treturn false;\n\t}\n\n\tconst referencedBlockName = getBlockName( state, reusableBlock.clientId );\n\tif ( ! referencedBlockName ) {\n\t\treturn false;\n\t}\n\n\tconst referencedBlockType = getBlockType( referencedBlockName );\n\tif ( ! referencedBlockType ) {\n\t\treturn false;\n\t}\n\n\tif ( ! canInsertBlockTypeUnmemoized( state, referencedBlockName, rootClientId ) ) {\n\t\treturn false;\n\t}\n\n\tif ( isAncestorOf( state, reusableBlock.clientId, rootClientId ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Determines the items that appear in the inserter. Includes both static\n * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).\n *\n * Each item object contains what's necessary to display a button in the\n * inserter and handle its selection.\n *\n * The 'utility' property indicates how useful we think an item will be to the\n * user. There are 4 levels of utility:\n *\n * 1. Blocks that are contextually useful (utility = 3)\n * 2. Blocks that have been previously inserted (utility = 2)\n * 3. Blocks that are in the common category (utility = 1)\n * 4. All other blocks (utility = 0)\n *\n * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)\n * that combines block usage frequenty and recency.\n *\n * Items are returned ordered descendingly by their 'utility' and 'frecency'.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Editor.InserterItem[]} Items that appear in inserter.\n *\n * @typedef {Object} Editor.InserterItem\n * @property {string}   id                Unique identifier for the item.\n * @property {string}   name              The type of block to create.\n * @property {Object}   initialAttributes Attributes to pass to the newly created block.\n * @property {string}   title             Title of the item, as it appears in the inserter.\n * @property {string}   icon              Dashicon for the item, as it appears in the inserter.\n * @property {string}   category          Block category that the item is associated with.\n * @property {string[]} keywords          Keywords that can be searched to find this item.\n * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting\n *                                        this item.\n * @property {number}   utility           How useful we think this item is, between 0 and 3.\n * @property {number}   frecency          Hueristic that combines frequency and recency.\n */\nexport const getInserterItems = createSelector(\n\t( state, rootClientId = null ) => {\n\t\tconst calculateUtility = ( category, count, isContextual ) => {\n\t\t\tif ( isContextual ) {\n\t\t\t\treturn INSERTER_UTILITY_HIGH;\n\t\t\t} else if ( count > 0 ) {\n\t\t\t\treturn INSERTER_UTILITY_MEDIUM;\n\t\t\t} else if ( category === 'common' ) {\n\t\t\t\treturn INSERTER_UTILITY_LOW;\n\t\t\t}\n\t\t\treturn INSERTER_UTILITY_NONE;\n\t\t};\n\n\t\tconst calculateFrecency = ( time, count ) => {\n\t\t\tif ( ! time ) {\n\t\t\t\treturn count;\n\t\t\t}\n\n\t\t\t// The selector is cached, which means Date.now() is the last time that the\n\t\t\t// relevant state changed. This suits our needs.\n\t\t\tconst duration = Date.now() - time;\n\n\t\t\tswitch ( true ) {\n\t\t\t\tcase duration < MILLISECONDS_PER_HOUR:\n\t\t\t\t\treturn count * 4;\n\t\t\t\tcase duration < MILLISECONDS_PER_DAY:\n\t\t\t\t\treturn count * 2;\n\t\t\t\tcase duration < MILLISECONDS_PER_WEEK:\n\t\t\t\t\treturn count / 2;\n\t\t\t\tdefault:\n\t\t\t\t\treturn count / 4;\n\t\t\t}\n\t\t};\n\n\t\tconst buildBlockTypeInserterItem = ( blockType ) => {\n\t\t\tconst id = blockType.name;\n\n\t\t\tlet isDisabled = false;\n\t\t\tif ( ! hasBlockSupport( blockType.name, 'multiple', true ) ) {\n\t\t\t\tisDisabled = some( getBlocksByClientId( state, getClientIdsWithDescendants( state ) ), { name: blockType.name } );\n\t\t\t}\n\n\t\t\tconst isContextual = isArray( blockType.parent );\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: blockType.name,\n\t\t\t\tinitialAttributes: {},\n\t\t\t\ttitle: blockType.title,\n\t\t\t\ticon: blockType.icon,\n\t\t\t\tcategory: blockType.category,\n\t\t\t\tkeywords: blockType.keywords,\n\t\t\t\tisDisabled,\n\t\t\t\tutility: calculateUtility( blockType.category, count, isContextual ),\n\t\t\t\tfrecency: calculateFrecency( time, count ),\n\t\t\t\thasChildBlocksWithInserterSupport: hasChildBlocksWithInserterSupport( blockType.name ),\n\t\t\t};\n\t\t};\n\n\t\tconst buildReusableBlockInserterItem = ( reusableBlock ) => {\n\t\t\tconst id = `core/block/${ reusableBlock.id }`;\n\n\t\t\tconst referencedBlockName = getBlockName( state, reusableBlock.clientId );\n\t\t\tconst referencedBlockType = getBlockType( referencedBlockName );\n\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\t\t\tconst utility = calculateUtility( 'reusable', count, false );\n\t\t\tconst frecency = calculateFrecency( time, count );\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: 'core/block',\n\t\t\t\tinitialAttributes: { ref: reusableBlock.id },\n\t\t\t\ttitle: reusableBlock.title,\n\t\t\t\ticon: referencedBlockType.icon,\n\t\t\t\tcategory: 'reusable',\n\t\t\t\tkeywords: [],\n\t\t\t\tisDisabled: false,\n\t\t\t\tutility,\n\t\t\t\tfrecency,\n\t\t\t};\n\t\t};\n\n\t\tconst blockTypeInserterItems = getBlockTypes()\n\t\t\t.filter( ( blockType ) => canIncludeBlockTypeInInserter( state, blockType, rootClientId ) )\n\t\t\t.map( buildBlockTypeInserterItem );\n\n\t\tconst reusableBlockInserterItems = getReusableBlocks( state )\n\t\t\t.filter( ( block ) => canIncludeReusableBlockInInserter( state, block, rootClientId ) )\n\t\t\t.map( buildReusableBlockInserterItem );\n\n\t\treturn orderBy(\n\t\t\t[ ...blockTypeInserterItems, ...reusableBlockInserterItems ],\n\t\t\t[ 'utility', 'frecency' ],\n\t\t\t[ 'desc', 'desc' ]\n\t\t);\n\t},\n\t( state, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.blocks.byClientId,\n\t\tstate.blocks.order,\n\t\tstate.preferences.insertUsage,\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t\tgetReusableBlocks( state ),\n\t\tgetBlockTypes(),\n\t],\n);\n\n/**\n * Determines whether there are items to show in the inserter.\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Items that appear in inserter.\n */\nexport const hasInserterItems = createSelector(\n\t( state, rootClientId = null ) => {\n\t\tconst hasBlockType = some(\n\t\t\tgetBlockTypes(),\n\t\t\t( blockType ) => canIncludeBlockTypeInInserter( state, blockType, rootClientId )\n\t\t);\n\t\tif ( hasBlockType ) {\n\t\t\treturn true;\n\t\t}\n\t\tconst hasReusableBlock = some(\n\t\t\tgetReusableBlocks( state ),\n\t\t\t( block ) => canIncludeReusableBlockInInserter( state, block, rootClientId )\n\t\t);\n\n\t\treturn hasReusableBlock;\n\t},\n\t( state, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.blocks.byClientId,\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t\tgetReusableBlocks( state ),\n\t\tgetBlockTypes(),\n\t],\n);\n\n/**\n * Returns the Block List settings of a block, if any exist.\n *\n * @param {Object}  state    Editor state.\n * @param {?string} clientId Block client ID.\n *\n * @return {?Object} Block settings of the block if set.\n */\nexport function getBlockListSettings( state, clientId ) {\n\treturn state.blockListSettings[ clientId ];\n}\n\n/**\n * Returns the editor settings.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The editor settings object.\n */\nexport function getSettings( state ) {\n\treturn state.settings;\n}\n\n/**\n * Returns true if the most recent block change is be considered persistent, or\n * false otherwise. A persistent change is one committed by BlockEditorProvider\n * via its `onChange` callback, in addition to `onInput`.\n *\n * @param {Object} state Block editor state.\n *\n * @return {boolean} Whether the most recent block change was persistent.\n */\nexport function isLastBlockChangePersistent( state ) {\n\treturn state.blocks.isPersistentChange;\n}\n\n/**\n * Returns the value of a post meta from the editor settings.\n *\n * @param {Object} state Global application state.\n * @param {string} key   Meta Key to retrieve\n *\n * @return {*} Meta value\n */\nfunction getPostMeta( state, key ) {\n\tif ( key === undefined ) {\n\t\treturn get( state, [ 'settings', '__experimentalMetaSource', 'value' ], EMPTY_OBJECT );\n\t}\n\n\treturn get( state, [ 'settings', '__experimentalMetaSource', 'value', key ] );\n}\n\n/**\n * Returns the available reusable blocks\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} Reusable blocks\n */\nfunction getReusableBlocks( state ) {\n\treturn get( state, [ 'settings', '__experimentalReusableBlocks' ], EMPTY_ARRAY );\n}\n"]}