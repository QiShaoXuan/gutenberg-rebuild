{"version":3,"sources":["@wordpress/block-editor/src/store/effects.js"],"names":["speak","getBlockType","doBlocksMatchTemplate","switchToBlockType","synchronizeBlocksWithTemplate","_n","sprintf","replaceBlocks","selectBlock","setTemplateValidity","insertDefaultBlock","resetBlocks","getBlock","getBlocks","getSelectedBlockCount","getBlockCount","getTemplateLock","getTemplate","isValidTemplate","validateBlocksToTemplate","action","store","state","getState","template","templateLock","isBlocksValidToTemplate","blocks","ensureDefaultBlock","MERGE_BLOCKS","dispatch","firstBlockClientId","secondBlockClientId","blockA","blockType","name","merge","clientId","blockB","blocksWithTheSameType","length","updatedAttributes","attributes","slice","RESET_BLOCKS","REPLACE_BLOCKS","MULTI_SELECT","blockCount","SYNCHRONIZE_TEMPLATE","updatedBlockList"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { speak } from '@wordpress/a11y';\nimport {\n\tgetBlockType,\n\tdoBlocksMatchTemplate,\n\tswitchToBlockType,\n\tsynchronizeBlocksWithTemplate,\n} from '@wordpress/blocks';\nimport { _n, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport {\n\treplaceBlocks,\n\tselectBlock,\n\tsetTemplateValidity,\n\tinsertDefaultBlock,\n\tresetBlocks,\n} from './actions';\nimport {\n\tgetBlock,\n\tgetBlocks,\n\tgetSelectedBlockCount,\n\tgetBlockCount,\n\tgetTemplateLock,\n\tgetTemplate,\n\tisValidTemplate,\n} from './selectors';\n\n/**\n * Block validity is a function of blocks state (at the point of a\n * reset) and the template setting. As a compromise to its placement\n * across distinct parts of state, it is implemented here as a side-\n * effect of the block reset action.\n *\n * @param {Object} action RESET_BLOCKS action.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} New validity set action if validity has changed.\n */\nexport function validateBlocksToTemplate( action, store ) {\n\tconst state = store.getState();\n\tconst template = getTemplate( state );\n\tconst templateLock = getTemplateLock( state );\n\n\t// Unlocked templates are considered always valid because they act\n\t// as default values only.\n\tconst isBlocksValidToTemplate = (\n\t\t! template ||\n\t\ttemplateLock !== 'all' ||\n\t\tdoBlocksMatchTemplate( action.blocks, template )\n\t);\n\n\t// Update if validity has changed.\n\tif ( isBlocksValidToTemplate !== isValidTemplate( state ) ) {\n\t\treturn setTemplateValidity( isBlocksValidToTemplate );\n\t}\n}\n\n/**\n * Effect handler which will return a default block insertion action if there\n * are no other blocks at the root of the editor. This is expected to be used\n * in actions which may result in no blocks remaining in the editor (removal,\n * replacement, etc).\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Default block insert action, if no other blocks exist.\n */\nexport function ensureDefaultBlock( action, store ) {\n\tif ( ! getBlockCount( store.getState() ) ) {\n\t\treturn insertDefaultBlock();\n\t}\n}\n\nexport default {\n\tMERGE_BLOCKS( action, store ) {\n\t\tconst { dispatch } = store;\n\t\tconst state = store.getState();\n\t\tconst [ firstBlockClientId, secondBlockClientId ] = action.blocks;\n\t\tconst blockA = getBlock( state, firstBlockClientId );\n\t\tconst blockType = getBlockType( blockA.name );\n\n\t\t// Only focus the previous block if it's not mergeable\n\t\tif ( ! blockType.merge ) {\n\t\t\tdispatch( selectBlock( blockA.clientId ) );\n\t\t\treturn;\n\t\t}\n\n\t\t// We can only merge blocks with similar types\n\t\t// thus, we transform the block to merge first\n\t\tconst blockB = getBlock( state, secondBlockClientId );\n\t\tconst blocksWithTheSameType = blockA.name === blockB.name ?\n\t\t\t[ blockB ] :\n\t\t\tswitchToBlockType( blockB, blockA.name );\n\n\t\t// If the block types can not match, do nothing\n\t\tif ( ! blocksWithTheSameType || ! blocksWithTheSameType.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calling the merge to update the attributes and remove the block to be merged\n\t\tconst updatedAttributes = blockType.merge(\n\t\t\tblockA.attributes,\n\t\t\tblocksWithTheSameType[ 0 ].attributes\n\t\t);\n\n\t\tdispatch( selectBlock( blockA.clientId, -1 ) );\n\t\tdispatch( replaceBlocks(\n\t\t\t[ blockA.clientId, blockB.clientId ],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t...blockA,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t...blockA.attributes,\n\t\t\t\t\t\t...updatedAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...blocksWithTheSameType.slice( 1 ),\n\t\t\t]\n\t\t) );\n\t},\n\tRESET_BLOCKS: [\n\t\tvalidateBlocksToTemplate,\n\t],\n\tREPLACE_BLOCKS: [\n\t\tensureDefaultBlock,\n\t],\n\tMULTI_SELECT: ( action, { getState } ) => {\n\t\tconst blockCount = getSelectedBlockCount( getState() );\n\n\t\t/* translators: %s: number of selected blocks */\n\t\tspeak( sprintf( _n( '%s block selected.', '%s blocks selected.', blockCount ), blockCount ), 'assertive' );\n\t},\n\tSYNCHRONIZE_TEMPLATE( action, { getState } ) {\n\t\tconst state = getState();\n\t\tconst blocks = getBlocks( state );\n\t\tconst template = getTemplate( state );\n\t\tconst updatedBlockList = synchronizeBlocksWithTemplate( blocks, template );\n\n\t\treturn resetBlocks( updatedBlockList );\n\t},\n};\n"]}