{"version":3,"sources":["@wordpress/block-editor/src/components/writing-flow/index.js"],"names":["overEvery","find","findLast","reverse","first","last","Component","computeCaretRect","focus","isHorizontalEdge","isTextField","isVerticalEdge","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","isEntirelySelected","UP","DOWN","LEFT","RIGHT","isKeyboardEvent","withSelect","withDispatch","compose","isBlockFocusStop","isInSameBlock","hasInnerBlocksContext","window","getSelection","isTabbableTextField","tabbable","isTabbableIndex","isNavigationCandidate","element","keyCode","hasModifier","isVertical","tagName","WritingFlow","arguments","onKeyDown","bind","bindContainer","clearVerticalRect","focusLastTextField","verticalRect","ref","container","target","isReverse","focusableNodes","focusable","slice","indexOf","isTabCandidate","node","i","array","contains","offset","nextNode","props","selectedBlockClientId","selectionStartClientId","selectionBeforeEndClientId","selectionAfterEndClientId","nextSelectionEndClientId","onMultiSelect","selectedFirstClientId","selectedLastClientId","focusedBlockClientId","onSelectBlock","closestTabbable","getClosestTabbable","event","hasMultiSelection","blocks","isUp","isDown","isLeft","isRight","isHorizontal","isNav","isShift","shiftKey","ctrlKey","altKey","metaKey","isNavEdge","primary","isContentEditable","preventDefault","nativeEvent","defaultPrevented","isTabbableEdge","expandSelection","moveSelection","isCollapsed","children","select","getSelectedBlockClientId","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getPreviousBlockClientId","getNextBlockClientId","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","getBlockOrder","selectionEndClientId","dispatch","multiSelect","selectBlock"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { overEvery, find, findLast, reverse, first, last } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component } from '@wordpress/element';\nimport {\n\tcomputeCaretRect,\n\tfocus,\n\tisHorizontalEdge,\n\tisTextField,\n\tisVerticalEdge,\n\tplaceCaretAtHorizontalEdge,\n\tplaceCaretAtVerticalEdge,\n\tisEntirelySelected,\n} from '@wordpress/dom';\nimport { UP, DOWN, LEFT, RIGHT, isKeyboardEvent } from '@wordpress/keycodes';\nimport { withSelect, withDispatch } from '@wordpress/data';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport {\n\tisBlockFocusStop,\n\tisInSameBlock,\n\thasInnerBlocksContext,\n} from '../../utils/dom';\n\n/**\n * Browser constants\n */\n\nconst { getSelection } = window;\n\n/**\n * Given an element, returns true if the element is a tabbable text field, or\n * false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is a tabbable text field.\n */\nconst isTabbableTextField = overEvery( [\n\tisTextField,\n\tfocus.tabbable.isTabbableIndex,\n] );\n\n/**\n * Returns true if the element should consider edge navigation upon a keyboard\n * event of the given directional key code, or false otherwise.\n *\n * @param {Element} element     HTML element to test.\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\n * @param {boolean} hasModifier Whether a modifier is pressed.\n *\n * @return {boolean} Whether element should consider edge navigation.\n */\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\n\tconst isVertical = ( keyCode === UP || keyCode === DOWN );\n\n\t// Currently, all elements support unmodified vertical navigation.\n\tif ( isVertical && ! hasModifier ) {\n\t\treturn true;\n\t}\n\n\t// Native inputs should not navigate horizontally.\n\tconst { tagName } = element;\n\treturn tagName !== 'INPUT' && tagName !== 'TEXTAREA';\n}\n\nclass WritingFlow extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.onKeyDown = this.onKeyDown.bind( this );\n\t\tthis.bindContainer = this.bindContainer.bind( this );\n\t\tthis.clearVerticalRect = this.clearVerticalRect.bind( this );\n\t\tthis.focusLastTextField = this.focusLastTextField.bind( this );\n\n\t\t/**\n\t\t * Here a rectangle is stored while moving the caret vertically so\n\t\t * vertical position of the start position can be restored.\n\t\t * This is to recreate browser behaviour across blocks.\n\t\t *\n\t\t * @type {?DOMRect}\n\t\t */\n\t\tthis.verticalRect = null;\n\t}\n\n\tbindContainer( ref ) {\n\t\tthis.container = ref;\n\t}\n\n\tclearVerticalRect() {\n\t\tthis.verticalRect = null;\n\t}\n\n\t/**\n\t * Returns the optimal tab target from the given focused element in the\n\t * desired direction. A preference is made toward text fields, falling back\n\t * to the block focus stop if no other candidates exist for the block.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {?Element} Optimal tab target, if one exists.\n\t */\n\tgetClosestTabbable( target, isReverse ) {\n\t\t// Since the current focus target is not guaranteed to be a text field,\n\t\t// find all focusables. Tabbability is considered later.\n\t\tlet focusableNodes = focus.focusable.find( this.container );\n\n\t\tif ( isReverse ) {\n\t\t\tfocusableNodes = reverse( focusableNodes );\n\t\t}\n\n\t\t// Consider as candidates those focusables after the current target.\n\t\t// It's assumed this can only be reached if the target is focusable\n\t\t// (on its keydown event), so no need to verify it exists in the set.\n\t\tfocusableNodes = focusableNodes.slice( focusableNodes.indexOf( target ) + 1 );\n\n\t\tfunction isTabCandidate( node, i, array ) {\n\t\t\t// Not a candidate if the node is not tabbable.\n\t\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prefer text fields...\n\t\t\tif ( isTextField( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// ...but settle for block focus stop.\n\t\t\tif ( ! isBlockFocusStop( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If element contains inner blocks, stop immediately at its focus\n\t\t\t// wrapper.\n\t\t\tif ( hasInnerBlocksContext( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// If navigating out of a block (in reverse), don't consider its\n\t\t\t// block focus stop.\n\t\t\tif ( node.contains( target ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// In case of block focus stop, check to see if there's a better\n\t\t\t// text field candidate within.\n\t\t\tfor ( let offset = 1, nextNode; ( nextNode = array[ i + offset ] ); offset++ ) {\n\t\t\t\t// Abort if no longer testing descendents of focus stop.\n\t\t\t\tif ( ! node.contains( nextNode ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Apply same tests by recursion. This is important to consider\n\t\t\t\t// nestable blocks where we don't want to settle for the inner\n\t\t\t\t// block focus stop.\n\t\t\t\tif ( isTabCandidate( nextNode, i + offset, array ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn find( focusableNodes, isTabCandidate );\n\t}\n\n\texpandSelection( isReverse ) {\n\t\tconst {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t} = this.props;\n\n\t\tconst nextSelectionEndClientId = isReverse ?\n\t\t\tselectionBeforeEndClientId :\n\t\t\tselectionAfterEndClientId;\n\n\t\tif ( nextSelectionEndClientId ) {\n\t\t\tthis.props.onMultiSelect(\n\t\t\t\tselectionStartClientId || selectedBlockClientId,\n\t\t\t\tnextSelectionEndClientId\n\t\t\t);\n\t\t}\n\t}\n\n\tmoveSelection( isReverse ) {\n\t\tconst { selectedFirstClientId, selectedLastClientId } = this.props;\n\n\t\tconst focusedBlockClientId = isReverse ? selectedFirstClientId : selectedLastClientId;\n\n\t\tif ( focusedBlockClientId ) {\n\t\t\tthis.props.onSelectBlock( focusedBlockClientId );\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the given target field is the last in its block which\n\t * can be considered for tab transition. For example, in a block with two\n\t * text fields, this would return true when reversing from the first of the\n\t * two fields, but false when reversing from the second.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {boolean} Whether field is at edge for tab transition.\n\t */\n\tisTabbableEdge( target, isReverse ) {\n\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\t\treturn ! closestTabbable || ! isInSameBlock( target, closestTabbable );\n\t}\n\n\tonKeyDown( event ) {\n\t\tconst {\n\t\t\thasMultiSelection,\n\t\t\tonMultiSelect,\n\t\t\tblocks,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t} = this.props;\n\n\t\tconst { keyCode, target } = event;\n\t\tconst isUp = keyCode === UP;\n\t\tconst isDown = keyCode === DOWN;\n\t\tconst isLeft = keyCode === LEFT;\n\t\tconst isRight = keyCode === RIGHT;\n\t\tconst isReverse = isUp || isLeft;\n\t\tconst isHorizontal = isLeft || isRight;\n\t\tconst isVertical = isUp || isDown;\n\t\tconst isNav = isHorizontal || isVertical;\n\t\tconst isShift = event.shiftKey;\n\t\tconst hasModifier = isShift || event.ctrlKey || event.altKey || event.metaKey;\n\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\n\n\t\t// This logic inside this condition needs to be checked before\n\t\t// the check for event.nativeEvent.defaultPrevented.\n\t\t// The logic handles meta+a keypress and this event is default prevented\n\t\t// by RichText.\n\t\tif ( ! isNav ) {\n\t\t\t// Set immediately before the meta+a combination can be pressed.\n\t\t\tif ( isKeyboardEvent.primary( event ) ) {\n\t\t\t\tthis.isEntirelySelected = isEntirelySelected( target );\n\t\t\t}\n\n\t\t\tif ( isKeyboardEvent.primary( event, 'a' ) ) {\n\t\t\t\t// When the target is contentEditable, selection will already\n\t\t\t\t// have been set by the browser earlier in this call stack. We\n\t\t\t\t// need check the previous result, otherwise all blocks will be\n\t\t\t\t// selected right away.\n\t\t\t\tif ( target.isContentEditable ? this.isEntirelySelected : isEntirelySelected( target ) ) {\n\t\t\t\t\tonMultiSelect( first( blocks ), last( blocks ) );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// After pressing primary + A we can assume isEntirelySelected is true.\n\t\t\t\t// Calling right away isEntirelySelected after primary + A may still return false on some browsers.\n\t\t\t\tthis.isEntirelySelected = true;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if navigation has already been handled (e.g. RichText inline\n\t\t// boundaries).\n\t\tif ( event.nativeEvent.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if our current target is not a candidate for navigation (e.g.\n\t\t// preserve native input behaviors).\n\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! isVertical ) {\n\t\t\tthis.verticalRect = null;\n\t\t} else if ( ! this.verticalRect ) {\n\t\t\tthis.verticalRect = computeCaretRect( target );\n\t\t}\n\n\t\tif ( isShift ) {\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t// Ensure that there is a target block.\n\t\t\t\t\t( isReverse && selectionBeforeEndClientId ) ||\n\t\t\t\t\t( ! isReverse && selectionAfterEndClientId )\n\t\t\t\t) && (\n\t\t\t\t\thasMultiSelection || (\n\t\t\t\t\t\tthis.isTabbableEdge( target, isReverse ) &&\n\t\t\t\t\t\tisNavEdge( target, isReverse )\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Shift key is down, and there is multi selection or we're at\n\t\t\t\t// the end of the current block.\n\t\t\t\tthis.expandSelection( isReverse );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( hasMultiSelection ) {\n\t\t\t// Moving from block multi-selection to single block selection\n\t\t\tthis.moveSelection( isReverse );\n\t\t\tevent.preventDefault();\n\t\t} else if ( isVertical && isVerticalEdge( target, isReverse ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\n\t\t\tif ( closestTabbable ) {\n\t\t\t\tplaceCaretAtVerticalEdge( closestTabbable, isReverse, this.verticalRect );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( isHorizontal && getSelection().isCollapsed && isHorizontalEdge( target, isReverse ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverse );\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Sets focus to the end of the last tabbable text field, if one exists.\n\t */\n\tfocusLastTextField() {\n\t\tconst focusableNodes = focus.focusable.find( this.container );\n\t\tconst target = findLast( focusableNodes, isTabbableTextField );\n\t\tif ( target ) {\n\t\t\tplaceCaretAtHorizontalEdge( target, true );\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { children } = this.props;\n\n\t\t// Disable reason: Wrapper itself is non-interactive, but must capture\n\t\t// bubbling events from children to determine focus transition intents.\n\t\t/* eslint-disable jsx-a11y/no-static-element-interactions */\n\t\treturn (\n\t\t\t<div className=\"editor-writing-flow block-editor-writing-flow\">\n\t\t\t\t<div\n\t\t\t\t\tref={ this.bindContainer }\n\t\t\t\t\tonKeyDown={ this.onKeyDown }\n\t\t\t\t\tonMouseDown={ this.clearVerticalRect }\n\t\t\t\t>\n\t\t\t\t\t{ children }\n\t\t\t\t</div>\n\t\t\t\t<div\n\t\t\t\t\taria-hidden\n\t\t\t\t\ttabIndex={ -1 }\n\t\t\t\t\tonClick={ this.focusLastTextField }\n\t\t\t\t\tclassName=\"wp-block editor-writing-flow__click-redirect block-editor-writing-flow__click-redirect\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t\t/* eslint-disable jsx-a11y/no-static-element-interactions */\n\t}\n}\n\nexport default compose( [\n\twithSelect( ( select ) => {\n\t\tconst {\n\t\t\tgetSelectedBlockClientId,\n\t\t\tgetMultiSelectedBlocksStartClientId,\n\t\t\tgetMultiSelectedBlocksEndClientId,\n\t\t\tgetPreviousBlockClientId,\n\t\t\tgetNextBlockClientId,\n\t\t\tgetFirstMultiSelectedBlockClientId,\n\t\t\tgetLastMultiSelectedBlockClientId,\n\t\t\thasMultiSelection,\n\t\t\tgetBlockOrder,\n\t\t} = select( 'core/block-editor' );\n\n\t\tconst selectedBlockClientId = getSelectedBlockClientId();\n\t\tconst selectionStartClientId = getMultiSelectedBlocksStartClientId();\n\t\tconst selectionEndClientId = getMultiSelectedBlocksEndClientId();\n\n\t\treturn {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId: getPreviousBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectionAfterEndClientId: getNextBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectedFirstClientId: getFirstMultiSelectedBlockClientId(),\n\t\t\tselectedLastClientId: getLastMultiSelectedBlockClientId(),\n\t\t\thasMultiSelection: hasMultiSelection(),\n\t\t\tblocks: getBlockOrder(),\n\t\t};\n\t} ),\n\twithDispatch( ( dispatch ) => {\n\t\tconst { multiSelect, selectBlock } = dispatch( 'core/block-editor' );\n\t\treturn {\n\t\t\tonMultiSelect: multiSelect,\n\t\t\tonSelectBlock: selectBlock,\n\t\t};\n\t} ),\n] )( WritingFlow );\n"]}