{"version":3,"sources":["@wordpress/block-editor/src/components/ignore-nested-events/index.js"],"names":["reduce","Component","forwardRef","IgnoreNestedEvents","arguments","proxyEvent","bind","eventMap","event","isHandled","nativeEvent","_blockHandled","propKey","type","props","childHandledEvents","forwardedRef","eventHandlers","Object","keys","result","key","match","isHandledProp","proxiedPropName","toLowerCase","forwardedIgnoreNestedEvents","ref","displayName"],"mappings":";;;;;;;;;;;AAAA;;;AAGA,SAASA,MAAT,QAAuB,QAAvB;AAEA;;;;AAGA,SAASC,SAAT,EAAoBC,UAApB,QAAsC,oBAAtC;AAEA;;;;;;;;;;;;;;;AAcA,WAAaC,kBAAb;AAAA;AAAA;AAAA;;AACC,gCAAc;AAAA;;AAAA;;AACb,6FAAUC,SAAV;AAEA,UAAKC,UAAL,GAAkB,MAAKA,UAAL,CAAgBC,IAAhB,uDAAlB,CAHa,CAKb;AACA;AACA;;AACA,UAAKC,QAAL,GAAgB,EAAhB;AARa;AASb;AAED;;;;;;;;;;AAZD;AAAA;AAAA,+BAoBaC,KApBb,EAoBqB;AACnB,UAAMC,SAAS,GAAG,CAAC,CAAED,KAAK,CAACE,WAAN,CAAkBC,aAAvC,CADmB,CAGnB;AACA;AACA;AACA;;AACAH,MAAAA,KAAK,CAACE,WAAN,CAAkBC,aAAlB,GAAkC,IAAlC,CAPmB,CASnB;;AACA,UAAIC,OAAO,GAAG,KAAKL,QAAL,CAAeC,KAAK,CAACK,IAArB,CAAd,CAVmB,CAYnB;AACA;;AACA,UAAKJ,SAAL,EAAiB;AAChBG,QAAAA,OAAO,IAAI,SAAX;AACA;;AAED,UAAK,KAAKE,KAAL,CAAYF,OAAZ,CAAL,EAA6B;AAC5B,aAAKE,KAAL,CAAYF,OAAZ,EAAuBJ,KAAvB;AACA;AACD;AAzCF;AAAA;AAAA,6BA2CU;AAAA;;AAAA,wBACoD,KAAKM,KADzD;AAAA,8CACAC,kBADA;AAAA,UACAA,kBADA,sCACqB,EADrB;AAAA,UACyBC,YADzB,eACyBA,YADzB;AAAA,UAC0CF,KAD1C;;AAGR,UAAMG,aAAa,GAAGjB,MAAM,8BACxBe,kBADwB,sBAExBG,MAAM,CAACC,IAAP,CAAaL,KAAb,CAFwB,IAGzB,UAAEM,MAAF,EAAUC,GAAV,EAAmB;AACrB;AACA,YAAMC,KAAK,GAAGD,GAAG,CAACC,KAAJ,CAAW,iCAAX,CAAd;;AACA,YAAKA,KAAL,EAAa;AACZ,cAAMC,aAAa,GAAG,CAAC,CAAED,KAAK,CAAE,CAAF,CAA9B;;AACA,cAAKC,aAAL,EAAqB;AACpB;AACA;AACA,mBAAOT,KAAK,CAAEO,GAAF,CAAZ;AACA,WANW,CAQZ;AACA;;;AACA,cAAMG,eAAe,GAAG,OAAOF,KAAK,CAAE,CAAF,CAApC;AACAF,UAAAA,MAAM,CAAEI,eAAF,CAAN,GAA4B,MAAI,CAACnB,UAAjC,CAXY,CAaZ;AACA;AACA;;AACA,UAAA,MAAI,CAACE,QAAL,CAAee,KAAK,CAAE,CAAF,CAAL,CAAWG,WAAX,EAAf,IAA4CD,eAA5C;AACA;;AAED,eAAOJ,MAAP;AACA,OA1B2B,EA0BzB,EA1ByB,CAA5B;AA4BA,aAAO;AAAK,QAAA,GAAG,EAAGJ;AAAX,SAA+BF,KAA/B,EAA4CG,aAA5C,EAAP;AACA;AA3EF;;AAAA;AAAA,EAAwChB,SAAxC;;AA8EA,IAAMyB,2BAA2B,GAAG,SAA9BA,2BAA8B,CAAEZ,KAAF,EAASa,GAAT,EAAkB;AACrD,SAAO,cAAC,kBAAD,eAAyBb,KAAzB;AAAiC,IAAA,YAAY,EAAGa;AAAhD,KAAP;AACA,CAFD;;AAGAD,2BAA2B,CAACE,WAA5B,GAA0C,oBAA1C;AAEA,eAAe1B,UAAU,CAAEwB,2BAAF,CAAzB","sourcesContent":["/**\n * External dependencies\n */\nimport { reduce } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component, forwardRef } from '@wordpress/element';\n\n/**\n * Component which renders a div with passed props applied except the optional\n * `childHandledEvents` prop. Event prop handlers are replaced with a proxying\n * event handler to capture and prevent events from being handled by ancestor\n * `IgnoreNestedEvents` elements by testing the presence of a private property\n * assigned on the event object.\n *\n * Optionally accepts an `childHandledEvents` prop array, which can be used in\n * instances where an inner `IgnoreNestedEvents` element exists and the outer\n * element should stop propagation but not invoke a callback handler, since it\n * would be assumed these are invoked by the child element.\n *\n * @type {Component}\n */\nexport class IgnoreNestedEvents extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.proxyEvent = this.proxyEvent.bind( this );\n\n\t\t// The event map is responsible for tracking an event type to a React\n\t\t// component prop name, since it is easy to determine event type from\n\t\t// a React prop name, but not the other way around.\n\t\tthis.eventMap = {};\n\t}\n\n\t/**\n\t * General event handler which only calls to its original props callback if\n\t * it has not already been handled by a descendant IgnoreNestedEvents.\n\t *\n\t * @param {Event} event Event object.\n\t *\n\t * @return {void}\n\t */\n\tproxyEvent( event ) {\n\t\tconst isHandled = !! event.nativeEvent._blockHandled;\n\n\t\t// Assign into the native event, since React will reuse their synthetic\n\t\t// event objects and this property assignment could otherwise leak.\n\t\t//\n\t\t// See: https://reactjs.org/docs/events.html#event-pooling\n\t\tevent.nativeEvent._blockHandled = true;\n\n\t\t// Invoke original prop handler\n\t\tlet propKey = this.eventMap[ event.type ];\n\n\t\t// If already handled (i.e. assume nested block), only invoke a\n\t\t// corresponding \"Handled\"-suffixed prop callback.\n\t\tif ( isHandled ) {\n\t\t\tpropKey += 'Handled';\n\t\t}\n\n\t\tif ( this.props[ propKey ] ) {\n\t\t\tthis.props[ propKey ]( event );\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { childHandledEvents = [], forwardedRef, ...props } = this.props;\n\n\t\tconst eventHandlers = reduce( [\n\t\t\t...childHandledEvents,\n\t\t\t...Object.keys( props ),\n\t\t], ( result, key ) => {\n\t\t\t// Try to match prop key as event handler\n\t\t\tconst match = key.match( /^on([A-Z][a-zA-Z]+?)(Handled)?$/ );\n\t\t\tif ( match ) {\n\t\t\t\tconst isHandledProp = !! match[ 2 ];\n\t\t\t\tif ( isHandledProp ) {\n\t\t\t\t\t// Avoid assigning through the invalid prop key. This\n\t\t\t\t\t// assumes mutation of shallow clone by above spread.\n\t\t\t\t\tdelete props[ key ];\n\t\t\t\t}\n\n\t\t\t\t// Re-map the prop to the local proxy handler to check whether\n\t\t\t\t// the event has already been handled.\n\t\t\t\tconst proxiedPropName = 'on' + match[ 1 ];\n\t\t\t\tresult[ proxiedPropName ] = this.proxyEvent;\n\n\t\t\t\t// Assign event -> propName into an instance variable, so as to\n\t\t\t\t// avoid re-renders which could be incurred either by setState\n\t\t\t\t// or in mapping values to a newly created function.\n\t\t\t\tthis.eventMap[ match[ 1 ].toLowerCase() ] = proxiedPropName;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {} );\n\n\t\treturn <div ref={ forwardedRef } { ...props } { ...eventHandlers } />;\n\t}\n}\n\nconst forwardedIgnoreNestedEvents = ( props, ref ) => {\n\treturn <IgnoreNestedEvents { ...props } forwardedRef={ ref } />;\n};\nforwardedIgnoreNestedEvents.displayName = 'IgnoreNestedEvents';\n\nexport default forwardRef( forwardedIgnoreNestedEvents );\n"]}