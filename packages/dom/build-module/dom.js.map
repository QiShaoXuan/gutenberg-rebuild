{"version":3,"sources":["@wordpress/dom/src/dom.js"],"names":["includes","window","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isEdge","container","isReverse","onlyVertical","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","rangeCount","rangeRect","getRectangleFromRange","getRangeAt","computedStyle","lineHeight","parseInt","isCollapsed","height","buffer","containerRect","getBoundingClientRect","verticalEdge","top","bottom","x","left","right","y","testRange","hiddenCaretRangeFromPoint","document","side","testRect","Math","round","isHorizontalEdge","isVerticalEdge","range","collapsed","startContainer","nodeName","parentNode","index","Array","from","childNodes","indexOf","createRange","setStart","setEnd","rect","getClientRects","padNode","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","collapse","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","style","zIndex","placeCaretAtVerticalEdge","mayUseScroll","editableRect","contains","scrollIntoView","nodeType","parentRect","padding","getPropertyValue","actualY","isTextField","element","contentEditable","error","documentHasSelection","activeElement","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","data","firstChild","getScrollContainer","node","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","ownerDocument","createElement","appendChild","replaceChild","wrap"],"mappings":"AAAA;;;AAGA,SAASA,QAAT,QAAyB,QAAzB;AAEA;;;;cAI6BC,M;IAArBC,gB,WAAAA,gB;mBAMJD,MAAM,CAACE,I;IAJVC,S,gBAAAA,S;IACAC,Y,gBAAAA,Y;IACAC,2B,gBAAAA,2B;IACAC,2B,gBAAAA,2B;AAGD;;;;;;;;;;;AAUA,SAASC,kBAAT,CAA6BC,SAA7B,EAAyC;AAAA,MAEvCC,UAFuC,GAMpCD,SANoC,CAEvCC,UAFuC;AAAA,MAGvCC,SAHuC,GAMpCF,SANoC,CAGvCE,SAHuC;AAAA,MAIvCC,YAJuC,GAMpCH,SANoC,CAIvCG,YAJuC;AAAA,MAKvCC,WALuC,GAMpCJ,SANoC,CAKvCI,WALuC;AAQxC,MAAMC,QAAQ,GAAGJ,UAAU,CAACK,uBAAX,CAAoCJ,SAApC,CAAjB,CARwC,CAUxC;AACA;;AACA;AACA;AACA;;AACA,MAAKG,QAAQ,GAAGR,2BAAhB,EAA8C;AAC7C,WAAO,KAAP;AACA;;AAED,MAAKQ,QAAQ,GAAGP,2BAAhB,EAA8C;AAC7C,WAAO,IAAP;AACA;AACD;AAEA;AACA;;;AACA,MAAKO,QAAQ,KAAK,CAAlB,EAAsB;AACrB,WAAOF,YAAY,IAAIC,WAAvB;AACA,GA5BuC,CA8BxC;;;AACA,SAAO,IAAP;AACA;AAED;;;;;;;;;;;;;AAWA,SAASG,MAAT,CAAiBC,SAAjB,EAA4BC,SAA5B,EAAuCC,YAAvC,EAAsD;AACrD,MAAKnB,QAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BiB,SAAS,CAACG,OAArC,CAAb,EAA8D;AAC7D,QAAKH,SAAS,CAACI,cAAV,KAA6BJ,SAAS,CAACK,YAA5C,EAA2D;AAC1D,aAAO,KAAP;AACA;;AAED,QAAKJ,SAAL,EAAiB;AAChB,aAAOD,SAAS,CAACI,cAAV,KAA6B,CAApC;AACA;;AAED,WAAOJ,SAAS,CAACM,KAAV,CAAgBC,MAAhB,KAA2BP,SAAS,CAACI,cAA5C;AACA;;AAED,MAAK,CAAEJ,SAAS,CAACQ,iBAAjB,EAAqC;AACpC,WAAO,IAAP;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;;AAEA,MAAK,CAAEjB,SAAS,CAACkB,UAAjB,EAA8B;AAC7B,WAAO,KAAP;AACA;;AAED,MAAMC,SAAS,GAAGC,qBAAqB,CAAEpB,SAAS,CAACqB,UAAV,CAAsB,CAAtB,CAAF,CAAvC;;AAEA,MAAK,CAAEF,SAAP,EAAmB;AAClB,WAAO,KAAP;AACA;;AAED,MAAMG,aAAa,GAAG9B,MAAM,CAACC,gBAAP,CAAyBe,SAAzB,CAAtB;AACA,MAAMe,UAAU,GAAGC,QAAQ,CAAEF,aAAa,CAACC,UAAhB,EAA4B,EAA5B,CAA3B,CA9BqD,CAgCrD;AACA;;AACA,MACC,CAAEvB,SAAS,CAACyB,WAAZ,IACAN,SAAS,CAACO,MAAV,GAAmBH,UADnB,IAEAxB,kBAAkB,CAAEC,SAAF,CAAlB,KAAoCS,SAHrC,EAIE;AACD,WAAO,KAAP;AACA,GAxCoD,CA0CrD;AACA;AACA;AACA;;;AACA,MAAMkB,MAAM,GAAG,IAAIH,QAAQ,CAAED,UAAF,EAAc,EAAd,CAAZ,GAAiC,CAAhD;AACA,MAAMK,aAAa,GAAGpB,SAAS,CAACqB,qBAAV,EAAtB;AACA,MAAMC,YAAY,GAAGrB,SAAS,GAC7BmB,aAAa,CAACG,GAAd,GAAoBZ,SAAS,CAACY,GAAV,GAAgBJ,MADP,GAE7BC,aAAa,CAACI,MAAd,GAAuBb,SAAS,CAACa,MAAV,GAAmBL,MAF3C;;AAIA,MAAK,CAAEG,YAAP,EAAsB;AACrB,WAAO,KAAP;AACA;;AAED,MAAKpB,YAAL,EAAoB;AACnB,WAAO,IAAP;AACA,GA1DoD,CA4DrD;AACA;AACA;AACA;AACA;;;AACA,MAAMuB,CAAC,GAAGxB,SAAS,GAAGmB,aAAa,CAACM,IAAd,GAAqB,CAAxB,GAA4BN,aAAa,CAACO,KAAd,GAAsB,CAArE;AACA,MAAMC,CAAC,GAAG3B,SAAS,GAAGmB,aAAa,CAACG,GAAd,GAAoBJ,MAAvB,GAAgCC,aAAa,CAACI,MAAd,GAAuBL,MAA1E;AACA,MAAMU,SAAS,GAAGC,yBAAyB,CAAEC,QAAF,EAAYN,CAAZ,EAAeG,CAAf,EAAkB5B,SAAlB,CAA3C;;AAEA,MAAK,CAAE6B,SAAP,EAAmB;AAClB,WAAO,KAAP;AACA;;AAED,MAAMG,IAAI,GAAG/B,SAAS,GAAG,MAAH,GAAY,OAAlC;AACA,MAAMgC,QAAQ,GAAGrB,qBAAqB,CAAEiB,SAAF,CAAtC;AAEA,SAAOK,IAAI,CAACC,KAAL,CAAYF,QAAQ,CAAED,IAAF,CAApB,MAAmCE,IAAI,CAACC,KAAL,CAAYxB,SAAS,CAAEqB,IAAF,CAArB,CAA1C;AACA;AAED;;;;;;;;;;AAQA,OAAO,SAASI,gBAAT,CAA2BpC,SAA3B,EAAsCC,SAAtC,EAAkD;AACxD,SAAOF,MAAM,CAAEC,SAAF,EAAaC,SAAb,CAAb;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASoC,cAAT,CAAyBrC,SAAzB,EAAoCC,SAApC,EAAgD;AACtD,SAAOF,MAAM,CAAEC,SAAF,EAAaC,SAAb,EAAwB,IAAxB,CAAb;AACA;AAED;;;;;;;;AAOA,OAAO,SAASW,qBAAT,CAAgC0B,KAAhC,EAAwC;AAC9C;AACA;AACA;AACA,MAAK,CAAEA,KAAK,CAACC,SAAb,EAAyB;AACxB,WAAOD,KAAK,CAACjB,qBAAN,EAAP;AACA;;AAN6C,eAQnBiB,KARmB;AAAA,MAQtCE,cARsC,UAQtCA,cARsC,EAU9C;;AACA,MAAKA,cAAc,CAACC,QAAf,KAA4B,IAAjC,EAAwC;AAAA,QAC/BC,UAD+B,GAChBF,cADgB,CAC/BE,UAD+B;AAEvC,QAAMC,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAYH,UAAU,CAACI,UAAvB,EAAoCC,OAApC,CAA6CP,cAA7C,CAAd;AAEAF,IAAAA,KAAK,GAAGP,QAAQ,CAACiB,WAAT,EAAR;AACAV,IAAAA,KAAK,CAACW,QAAN,CAAgBP,UAAhB,EAA4BC,KAA5B;AACAL,IAAAA,KAAK,CAACY,MAAN,CAAcR,UAAd,EAA0BC,KAA1B;AACA;;AAED,MAAIQ,IAAI,GAAGb,KAAK,CAACc,cAAN,GAAwB,CAAxB,CAAX,CApB8C,CAsB9C;AACA;AACA;AACA;AACA;;AACA,MAAK,CAAED,IAAP,EAAc;AACb,QAAME,OAAO,GAAGtB,QAAQ,CAACuB,cAAT,CAAyB,QAAzB,CAAhB;AACAhB,IAAAA,KAAK,CAACiB,UAAN,CAAkBF,OAAlB;AACAF,IAAAA,IAAI,GAAGb,KAAK,CAACc,cAAN,GAAwB,CAAxB,CAAP;AACAC,IAAAA,OAAO,CAACX,UAAR,CAAmBc,WAAnB,CAAgCH,OAAhC;AACA;;AAED,SAAOF,IAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASM,gBAAT,CAA2BzD,SAA3B,EAAuC;AAC7C,MAAK,CAAEA,SAAS,CAACQ,iBAAjB,EAAqC;AACpC;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAM6B,KAAK,GAAG9C,SAAS,CAACkB,UAAV,GAAuBlB,SAAS,CAACqB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;;AAEA,MAAK,CAAEyB,KAAP,EAAe;AACd;AACA;;AAED,SAAO1B,qBAAqB,CAAE0B,KAAF,CAA5B;AACA;AAED;;;;;;;AAMA,OAAO,SAASoB,0BAAT,CAAqC1D,SAArC,EAAgDC,SAAhD,EAA4D;AAClE,MAAK,CAAED,SAAP,EAAmB;AAClB;AACA;;AAED,MAAKjB,QAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BiB,SAAS,CAACG,OAArC,CAAb,EAA8D;AAC7DH,IAAAA,SAAS,CAAC2D,KAAV;;AACA,QAAK1D,SAAL,EAAiB;AAChBD,MAAAA,SAAS,CAACI,cAAV,GAA2BJ,SAAS,CAACM,KAAV,CAAgBC,MAA3C;AACAP,MAAAA,SAAS,CAACK,YAAV,GAAyBL,SAAS,CAACM,KAAV,CAAgBC,MAAzC;AACA,KAHD,MAGO;AACNP,MAAAA,SAAS,CAACI,cAAV,GAA2B,CAA3B;AACAJ,MAAAA,SAAS,CAACK,YAAV,GAAyB,CAAzB;AACA;;AACD;AACA;;AAEDL,EAAAA,SAAS,CAAC2D,KAAV;;AAEA,MAAK,CAAE3D,SAAS,CAACQ,iBAAjB,EAAqC;AACpC;AACA,GArBiE,CAuBlE;AACA;AACA;;;AACA,MAAMoD,WAAW,GAAG5D,SAAS,CAAEC,SAAS,GAAG,WAAH,GAAiB,YAA5B,CAA7B,CA1BkE,CA4BlE;AACA;;AACA,MAAK,CAAE2D,WAAP,EAAqB;AACpB;AACA;;AAED,MAAMpE,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAM6B,KAAK,GAAGP,QAAQ,CAACiB,WAAT,EAAd;AAEAV,EAAAA,KAAK,CAACuB,kBAAN,CAA0BD,WAA1B;AACAtB,EAAAA,KAAK,CAACwB,QAAN,CAAgB,CAAE7D,SAAlB;AAEAT,EAAAA,SAAS,CAACuE,eAAV;AACAvE,EAAAA,SAAS,CAACwE,QAAV,CAAoB1B,KAApB;AACA;AAED;;;;;;;;;;;;;AAYA,SAAS2B,mBAAT,CAA8BC,GAA9B,EAAmCzC,CAAnC,EAAsCG,CAAtC,EAA0C;AACzC,MAAKsC,GAAG,CAACD,mBAAT,EAA+B;AAC9B,WAAOC,GAAG,CAACD,mBAAJ,CAAyBxC,CAAzB,EAA4BG,CAA5B,CAAP;AACA;;AAED,MAAK,CAAEsC,GAAG,CAACC,sBAAX,EAAoC;AACnC,WAAO,IAAP;AACA;;AAED,MAAMC,KAAK,GAAGF,GAAG,CAACC,sBAAJ,CAA4B1C,CAA5B,EAA+BG,CAA/B,CAAd,CATyC,CAWzC;AACA;;AACA,MAAK,CAAEwC,KAAP,EAAe;AACd,WAAO,IAAP;AACA;;AAED,MAAM9B,KAAK,GAAG4B,GAAG,CAAClB,WAAJ,EAAd;AAEAV,EAAAA,KAAK,CAACW,QAAN,CAAgBmB,KAAK,CAACC,UAAtB,EAAkCD,KAAK,CAACE,MAAxC;AACAhC,EAAAA,KAAK,CAACwB,QAAN,CAAgB,IAAhB;AAEA,SAAOxB,KAAP;AACA;AAED;;;;;;;;;;;;;;AAYA,SAASR,yBAAT,CAAoCoC,GAApC,EAAyCzC,CAAzC,EAA4CG,CAA5C,EAA+C5B,SAA/C,EAA2D;AAC1DA,EAAAA,SAAS,CAACuE,KAAV,CAAgBC,MAAhB,GAAyB,OAAzB;AAEA,MAAMlC,KAAK,GAAG2B,mBAAmB,CAAEC,GAAF,EAAOzC,CAAP,EAAUG,CAAV,CAAjC;AAEA5B,EAAAA,SAAS,CAACuE,KAAV,CAAgBC,MAAhB,GAAyB,IAAzB;AAEA,SAAOlC,KAAP;AACA;AAED;;;;;;;;;;AAQA,OAAO,SAASmC,wBAAT,CAAmCzE,SAAnC,EAA8CC,SAA9C,EAAyDkD,IAAzD,EAAqF;AAAA,MAAtBuB,YAAsB,uEAAP,IAAO;;AAC3F,MAAK,CAAE1E,SAAP,EAAmB;AAClB;AACA;;AAED,MAAK,CAAEmD,IAAF,IAAU,CAAEnD,SAAS,CAACQ,iBAA3B,EAA+C;AAC9CkD,IAAAA,0BAA0B,CAAE1D,SAAF,EAAaC,SAAb,CAA1B;AACA;AACA,GAR0F,CAU3F;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMkB,MAAM,GAAGgC,IAAI,CAACjC,MAAL,GAAc,CAA7B;AACA,MAAMyD,YAAY,GAAG3E,SAAS,CAACqB,qBAAV,EAArB;AACA,MAAMI,CAAC,GAAG0B,IAAI,CAACzB,IAAf;AACA,MAAME,CAAC,GAAG3B,SAAS,GAAK0E,YAAY,CAACnD,MAAb,GAAsBL,MAA3B,GAAwCwD,YAAY,CAACpD,GAAb,GAAmBJ,MAA9E;AAEA,MAAImB,KAAK,GAAGR,yBAAyB,CAAEC,QAAF,EAAYN,CAAZ,EAAeG,CAAf,EAAkB5B,SAAlB,CAArC;;AAEA,MAAK,CAAEsC,KAAF,IAAW,CAAEtC,SAAS,CAAC4E,QAAV,CAAoBtC,KAAK,CAACE,cAA1B,CAAlB,EAA+D;AAC9D,QAAKkC,YAAY,KACd,CAAEpC,KAAF,IAAW,CAAEA,KAAK,CAACE,cAArB,IACC,CAAEF,KAAK,CAACE,cAAN,CAAqBoC,QAArB,CAA+B5E,SAA/B,CAFa,CAAjB,EAEmD;AAClD;AACA;AACAA,MAAAA,SAAS,CAAC6E,cAAV,CAA0B5E,SAA1B;AACAwE,MAAAA,wBAAwB,CAAEzE,SAAF,EAAaC,SAAb,EAAwBkD,IAAxB,EAA8B,KAA9B,CAAxB;AACA;AACA;;AAEDO,IAAAA,0BAA0B,CAAE1D,SAAF,EAAaC,SAAb,CAA1B;AACA;AACA,GApC0F,CAsC3F;AACA;;;AACA,MAAKqC,KAAK,CAACE,cAAN,CAAqBsC,QAArB,KAAkC3F,SAAvC,EAAmD;AAClD,QAAMuD,UAAU,GAAGJ,KAAK,CAACE,cAAN,CAAqBE,UAAxC;AACA,QAAMqC,UAAU,GAAGrC,UAAU,CAACrB,qBAAX,EAAnB;AACA,QAAMW,IAAI,GAAG/B,SAAS,GAAG,QAAH,GAAc,KAApC;AACA,QAAM+E,OAAO,GAAGhE,QAAQ,CAAE/B,gBAAgB,CAAEyD,UAAF,CAAhB,CAA+BuC,gBAA/B,mBAA6DjD,IAA7D,EAAF,EAA0E,EAA1E,CAAR,IAA0F,CAA1G;AACA,QAAMkD,OAAO,GAAGjF,SAAS,GAAK8E,UAAU,CAACvD,MAAX,GAAoBwD,OAApB,GAA8B7D,MAAnC,GAAgD4D,UAAU,CAACxD,GAAX,GAAiByD,OAAjB,GAA2B7D,MAApG;;AAEA,QAAKS,CAAC,KAAKsD,OAAX,EAAqB;AACpB5C,MAAAA,KAAK,GAAGR,yBAAyB,CAAEC,QAAF,EAAYN,CAAZ,EAAeyD,OAAf,EAAwBlF,SAAxB,CAAjC;AACA;AACD;;AAED,MAAMR,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACAjB,EAAAA,SAAS,CAACuE,eAAV;AACAvE,EAAAA,SAAS,CAACwE,QAAV,CAAoB1B,KAApB;AACAtC,EAAAA,SAAS,CAAC2D,KAAV,GAvD2F,CAwD3F;AACA;;AACAnE,EAAAA,SAAS,CAACuE,eAAV;AACAvE,EAAAA,SAAS,CAACwE,QAAV,CAAoB1B,KAApB;AACA;AAED;;;;;;;;;;;AAUA,OAAO,SAAS6C,WAAT,CAAsBC,OAAtB,EAAgC;AACtC,MAAI;AAAA,QACK3C,QADL,GACmD2C,OADnD,CACK3C,QADL;AAAA,QACerC,cADf,GACmDgF,OADnD,CACehF,cADf;AAAA,QAC+BiF,eAD/B,GACmDD,OADnD,CAC+BC,eAD/B;AAGH,WACG5C,QAAQ,KAAK,OAAb,IAAwBrC,cAAc,KAAK,IAA7C,IACEqC,QAAQ,KAAK,UADf,IAEA4C,eAAe,KAAK,MAHrB;AAKA,GARD,CAQE,OAAQC,KAAR,EAAgB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAO,KAAP;AACA;AACD;AAED;;;;;;;AAMA,OAAO,SAASC,oBAAT,GAAgC;AACtC,MAAKJ,WAAW,CAAEpD,QAAQ,CAACyD,aAAX,CAAhB,EAA6C;AAC5C,WAAO,IAAP;AACA;;AAED,MAAMhG,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAM6B,KAAK,GAAG9C,SAAS,CAACkB,UAAV,GAAuBlB,SAAS,CAACqB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;AAEA,SAAOyB,KAAK,IAAI,CAAEA,KAAK,CAACC,SAAxB;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASkD,kBAAT,CAA6BL,OAA7B,EAAuC;AAC7C,MAAKrG,QAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BqG,OAAO,CAAC3C,QAAnC,CAAb,EAA6D;AAC5D,WAAO2C,OAAO,CAAChF,cAAR,KAA2B,CAA3B,IAAgCgF,OAAO,CAAC9E,KAAR,CAAcC,MAAd,KAAyB6E,OAAO,CAAC/E,YAAxE;AACA;;AAED,MAAK,CAAE+E,OAAO,CAAC5E,iBAAf,EAAmC;AAClC,WAAO,IAAP;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAM6B,KAAK,GAAG9C,SAAS,CAACkB,UAAV,GAAuBlB,SAAS,CAACqB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;;AAEA,MAAK,CAAEyB,KAAP,EAAe;AACd,WAAO,IAAP;AACA;;AAd4C,MAgBrCE,cAhBqC,GAgBoBF,KAhBpB,CAgBrCE,cAhBqC;AAAA,MAgBrBkD,YAhBqB,GAgBoBpD,KAhBpB,CAgBrBoD,YAhBqB;AAAA,MAgBPC,WAhBO,GAgBoBrD,KAhBpB,CAgBPqD,WAhBO;AAAA,MAgBMC,SAhBN,GAgBoBtD,KAhBpB,CAgBMsD,SAhBN;;AAkB7C,MACCpD,cAAc,KAAK4C,OAAnB,IACAM,YAAY,KAAKN,OADjB,IAEAO,WAAW,KAAK,CAFhB,IAGAC,SAAS,KAAKR,OAAO,CAACtC,UAAR,CAAmBvC,MAJlC,EAKE;AACD,WAAO,IAAP;AACA;;AAED,MAAMsF,SAAS,GAAGT,OAAO,CAACS,SAA1B;AACA,MAAMC,sBAAsB,GAAGD,SAAS,CAACf,QAAV,KAAuB3F,SAAvB,GAC9B0G,SAAS,CAACE,IAAV,CAAexF,MADe,GAE9BsF,SAAS,CAAC/C,UAAV,CAAqBvC,MAFtB;AAIA,SACCiC,cAAc,KAAK4C,OAAO,CAACY,UAA3B,IACAN,YAAY,KAAKN,OAAO,CAACS,SADzB,IAEAF,WAAW,KAAK,CAFhB,IAGAC,SAAS,KAAKE,sBAJf;AAMA;AAED;;;;;;;;AAOA,OAAO,SAASG,kBAAT,CAA6BC,IAA7B,EAAoC;AAC1C,MAAK,CAAEA,IAAP,EAAc;AACb;AACA,GAHyC,CAK1C;;;AACA,MAAKA,IAAI,CAACC,YAAL,GAAoBD,IAAI,CAACE,YAA9B,EAA6C;AAC5C;AAD4C,gCAEtBpH,MAAM,CAACC,gBAAP,CAAyBiH,IAAzB,CAFsB;AAAA,QAEpCG,SAFoC,yBAEpCA,SAFoC;;AAG5C,QAAK,gBAAgBC,IAAhB,CAAsBD,SAAtB,CAAL,EAAyC;AACxC,aAAOH,IAAP;AACA;AACD,GAZyC,CAc1C;;;AACA,SAAOD,kBAAkB,CAAEC,IAAI,CAACxD,UAAP,CAAzB;AACA;AAED;;;;;;;;;;;;AAWA,OAAO,SAAS6D,eAAT,CAA0BL,IAA1B,EAAiC;AACvC;AACA;AACA,MAAIM,cAAJ;;AACA,SAAUA,cAAc,GAAGN,IAAI,CAACxD,UAAhC,EAA+C;AAC9C,QAAK8D,cAAc,CAAC1B,QAAf,KAA4B1F,YAAjC,EAAgD;AAC/C;AACA;AACD;;AAED,MAAK,CAAEoH,cAAP,EAAwB;AACvB,WAAO,IAAP;AACA,GAZsC,CAcvC;AACA;;;AACA,MAAKvH,gBAAgB,CAAEuH,cAAF,CAAhB,CAAmC3G,QAAnC,KAAgD,QAArD,EAAgE;AAC/D,WAAO2G,cAAP;AACA;;AAED,SAAOA,cAAc,CAACC,YAAtB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,OAAT,CAAkBC,aAAlB,EAAiCC,OAAjC,EAA2C;AACjDC,EAAAA,WAAW,CAAED,OAAF,EAAWD,aAAa,CAACjE,UAAzB,CAAX;AACAoE,EAAAA,MAAM,CAAEH,aAAF,CAAN;AACA;AAED;;;;;;;AAMA,OAAO,SAASG,MAAT,CAAiBZ,IAAjB,EAAwB;AAC9BA,EAAAA,IAAI,CAACxD,UAAL,CAAgBc,WAAhB,CAA6B0C,IAA7B;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASW,WAAT,CAAsBD,OAAtB,EAA+BG,aAA/B,EAA+C;AACrDA,EAAAA,aAAa,CAACrE,UAAd,CAAyBsE,YAAzB,CAAuCJ,OAAvC,EAAgDG,aAAa,CAACE,WAA9D;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,MAAT,CAAiBhB,IAAjB,EAAwB;AAC9B,MAAMiB,MAAM,GAAGjB,IAAI,CAACxD,UAApB;;AAEA,SAAQwD,IAAI,CAACF,UAAb,EAA0B;AACzBmB,IAAAA,MAAM,CAACH,YAAP,CAAqBd,IAAI,CAACF,UAA1B,EAAsCE,IAAtC;AACA;;AAEDiB,EAAAA,MAAM,CAAC3D,WAAP,CAAoB0C,IAApB;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASkB,UAAT,CAAqBlB,IAArB,EAA2B/F,OAA3B,EAAqC;AAC3C,MAAMyG,OAAO,GAAGV,IAAI,CAACmB,aAAL,CAAmBC,aAAnB,CAAkCnH,OAAlC,CAAhB;;AAEA,SAAQ+F,IAAI,CAACF,UAAb,EAA0B;AACzBY,IAAAA,OAAO,CAACW,WAAR,CAAqBrB,IAAI,CAACF,UAA1B;AACA;;AAEDE,EAAAA,IAAI,CAACxD,UAAL,CAAgB8E,YAAhB,CAA8BZ,OAA9B,EAAuCV,IAAvC;AAEA,SAAOU,OAAP;AACA;AAED;;;;;;;AAMA,OAAO,SAASa,IAAT,CAAeb,OAAf,EAAwBG,aAAxB,EAAwC;AAC9CA,EAAAA,aAAa,CAACrE,UAAd,CAAyBsE,YAAzB,CAAuCJ,OAAvC,EAAgDG,aAAhD;AACAH,EAAAA,OAAO,CAACW,WAAR,CAAqBR,aAArB;AACA","sourcesContent":["/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Browser dependencies\n */\n\nconst { getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst {\n\t\tanchorNode,\n\t\tfocusNode,\n\t\tanchorOffset,\n\t\tfocusOffset,\n\t} = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst rangeRect = getRectangleFromRange( selection.getRangeAt( 0 ) );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst computedStyle = window.getComputedStyle( container );\n\tconst lineHeight = parseInt( computedStyle.lineHeight, 10 );\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge.\n\tif (\n\t\t! selection.isCollapsed &&\n\t\trangeRect.height > lineHeight &&\n\t\tisSelectionForward( selection ) === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// Calculate a buffer that is half the line height. In some browsers, the\n\t// selection rectangle may not fill the entire height of the line, so we add\n\t// 3/4 the line height to the selection rectangle to ensure that it is well\n\t// over its line boundary.\n\tconst buffer = 3 * parseInt( lineHeight, 10 ) / 4;\n\tconst containerRect = container.getBoundingClientRect();\n\tconst verticalEdge = isReverse ?\n\t\tcontainerRect.top > rangeRect.top - buffer :\n\t\tcontainerRect.bottom < rangeRect.bottom + buffer;\n\n\tif ( ! verticalEdge ) {\n\t\treturn false;\n\t}\n\n\tif ( onlyVertical ) {\n\t\treturn true;\n\t}\n\n\t// To calculate the horizontal position, we insert a test range and see if\n\t// this test range has the same horizontal position. This method proves to\n\t// be better than a DOM-based calculation, because it ignores empty text\n\t// nodes and a trailing line break element. In other words, we need to check\n\t// visual positioning, not DOM positioning.\n\tconst x = isReverse ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + buffer : containerRect.bottom - buffer;\n\tconst testRange = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst side = isReverse ? 'left' : 'right';\n\tconst testRect = getRectangleFromRange( testRange );\n\n\treturn Math.round( testRect[ side ] ) === Math.round( rangeRect[ side ] );\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf( startContainer );\n\n\t\trange = document.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Element} container Editable container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect( container ) {\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tcontainer.style.zIndex = '10000';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = null;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge( container, isReverse, rect, mayUseScroll = true ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse ? ( editableRect.bottom - buffer ) : ( editableRect.top + buffer );\n\n\tlet range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif ( mayUseScroll && (\n\t\t\t( ! range || ! range.startContainer ) ||\n\t\t\t\t! range.startContainer.contains( container ) ) ) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Check if the closest text node is actually further away.\n\t// If so, attempt to get the range again with the y position adjusted to get the right offset.\n\tif ( range.startContainer.nodeType === TEXT_NODE ) {\n\t\tconst parentNode = range.startContainer.parentNode;\n\t\tconst parentRect = parentNode.getBoundingClientRect();\n\t\tconst side = isReverse ? 'bottom' : 'top';\n\t\tconst padding = parseInt( getComputedStyle( parentNode ).getPropertyValue( `padding-${ side }` ), 10 ) || 0;\n\t\tconst actualY = isReverse ? ( parentRect.bottom - padding - buffer ) : ( parentRect.top + padding + buffer );\n\n\t\tif ( y !== actualY ) {\n\t\t\trange = hiddenCaretRangeFromPoint( document, x, actualY, container );\n\t\t}\n\t}\n\n\tconst selection = window.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\ttry {\n\t\tconst { nodeName, selectionStart, contentEditable } = element;\n\n\t\treturn (\n\t\t\t( nodeName === 'INPUT' && selectionStart !== null ) ||\n\t\t\t( nodeName === 'TEXTAREA' ) ||\n\t\t\tcontentEditable === 'true'\n\t\t);\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check wether the current document has a selection.\n * This checks both for focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\tif ( isTextField( document.activeElement ) ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn element.selectionStart === 0 && element.value.length === element.selectionEnd;\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength = lastChild.nodeType === TEXT_NODE ?\n\t\tlastChild.data.length :\n\t\tlastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n"]}