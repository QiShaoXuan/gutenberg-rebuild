import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";

/**
 * External dependencies
 */
import { get, isNumber, mapValues } from 'lodash';
/**
 * Filters an array based on the predicate, but keeps the reference the same if
 * the array hasn't changed.
 *
 * @param {Array}    collection The collection to filter.
 * @param {Function} predicate  Function that determines if the item should stay
 *                              in the array.
 * @return {Array} Filtered array.
 */

function filterWithReference(collection, predicate) {
  var filteredCollection = collection.filter(predicate);
  return collection.length === filteredCollection.length ? collection : filteredCollection;
}
/**
 * Verifies whether the given annotations is a valid annotation.
 *
 * @param {Object} annotation The annotation to verify.
 * @return {boolean} Whether the given annotation is valid.
 */


function isValidAnnotationRange(annotation) {
  return isNumber(annotation.start) && isNumber(annotation.end) && annotation.start <= annotation.end;
}
/**
 * Reducer managing annotations.
 *
 * @param {Array} state The annotations currently shown in the editor.
 * @param {Object} action Dispatched action.
 *
 * @return {Array} Updated state.
 */


export function annotations() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ANNOTATION_ADD':
      var blockClientId = action.blockClientId;
      var newAnnotation = {
        id: action.id,
        blockClientId: blockClientId,
        richTextIdentifier: action.richTextIdentifier,
        source: action.source,
        selector: action.selector,
        range: action.range
      };

      if (newAnnotation.selector === 'range' && !isValidAnnotationRange(newAnnotation.range)) {
        return state;
      }

      var previousAnnotationsForBlock = get(state, blockClientId, []);
      return _objectSpread({}, state, _defineProperty({}, blockClientId, [].concat(_toConsumableArray(previousAnnotationsForBlock), [newAnnotation])));

    case 'ANNOTATION_REMOVE':
      return mapValues(state, function (annotationsForBlock) {
        return filterWithReference(annotationsForBlock, function (annotation) {
          return annotation.id !== action.annotationId;
        });
      });

    case 'ANNOTATION_UPDATE_RANGE':
      return mapValues(state, function (annotationsForBlock) {
        var hasChangedRange = false;
        var newAnnotations = annotationsForBlock.map(function (annotation) {
          if (annotation.id === action.annotationId) {
            hasChangedRange = true;
            return _objectSpread({}, annotation, {
              range: {
                start: action.start,
                end: action.end
              }
            });
          }

          return annotation;
        });
        return hasChangedRange ? newAnnotations : annotationsForBlock;
      });

    case 'ANNOTATION_REMOVE_SOURCE':
      return mapValues(state, function (annotationsForBlock) {
        return filterWithReference(annotationsForBlock, function (annotation) {
          return annotation.source !== action.source;
        });
      });
  }

  return state;
}
export default annotations;
//# sourceMappingURL=reducer.js.map