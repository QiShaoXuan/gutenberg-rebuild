{"version":3,"sources":["@wordpress/annotations/src/store/selectors.js"],"names":["createSelector","get","flatMap","EMPTY_ARRAY","__experimentalGetAnnotationsForBlock","state","blockClientId","filter","annotation","selector","__experimentalGetAllAnnotationsForBlock","__experimentalGetAnnotationsForRichText","richTextIdentifier","map","range","other","__experimentalGetAnnotations","annotations"],"mappings":";;;AAAA;;;AAGA,OAAOA,cAAP,MAA2B,QAA3B;AACA,SAASC,GAAT,EAAcC,OAAd,QAA6B,QAA7B;AAEA;;;;;;;;;;AASA,IAAMC,WAAW,GAAG,EAApB;AAEA;;;;;;;;;AAQA,OAAO,IAAMC,oCAAoC,GAAGJ,cAAc,CACjE,UAAEK,KAAF,EAASC,aAAT,EAA4B;AAC3B,SAAOL,GAAG,CAAEI,KAAF,EAASC,aAAT,EAAwB,EAAxB,CAAH,CAAgCC,MAAhC,CAAwC,UAAEC,UAAF,EAAkB;AAChE,WAAOA,UAAU,CAACC,QAAX,KAAwB,OAA/B;AACA,GAFM,CAAP;AAGA,CALgE,EAMjE,UAAEJ,KAAF,EAASC,aAAT;AAAA,SAA4B,CAC3BL,GAAG,CAAEI,KAAF,EAASC,aAAT,EAAwBH,WAAxB,CADwB,CAA5B;AAAA,CANiE,CAA3D;AAWP,OAAO,IAAMO,uCAAuC,GAAG,SAA1CA,uCAA0C,CAAUL,KAAV,EAAiBC,aAAjB,EAAiC;AACvF,SAAOL,GAAG,CAAEI,KAAF,EAASC,aAAT,EAAwBH,WAAxB,CAAV;AACA,CAFM;AAIP;;;;;;;;;;;;;AAYA,OAAO,IAAMQ,uCAAuC,GAAGX,cAAc,CACpE,UAAEK,KAAF,EAASC,aAAT,EAAwBM,kBAAxB,EAAgD;AAC/C,SAAOX,GAAG,CAAEI,KAAF,EAASC,aAAT,EAAwB,EAAxB,CAAH,CAAgCC,MAAhC,CAAwC,UAAEC,UAAF,EAAkB;AAChE,WAAOA,UAAU,CAACC,QAAX,KAAwB,OAAxB,IACNG,kBAAkB,KAAKJ,UAAU,CAACI,kBADnC;AAEA,GAHM,EAGHC,GAHG,CAGE,UAAEL,UAAF,EAAkB;AAAA,QAClBM,KADkB,GACEN,UADF,CAClBM,KADkB;AAAA,QACRC,KADQ,4BACEP,UADF;;AAG1B,6BACIM,KADJ,EAEIC,KAFJ;AAIA,GAVM,CAAP;AAWA,CAbmE,EAcpE,UAAEV,KAAF,EAASC,aAAT;AAAA,SAA4B,CAC3BL,GAAG,CAAEI,KAAF,EAASC,aAAT,EAAwBH,WAAxB,CADwB,CAA5B;AAAA,CAdoE,CAA9D;AAmBP;;;;;;;AAMA,OAAO,SAASa,4BAAT,CAAuCX,KAAvC,EAA+C;AACrD,SAAOH,OAAO,CAAEG,KAAF,EAAS,UAAEY,WAAF,EAAmB;AACzC,WAAOA,WAAP;AACA,GAFa,CAAd;AAGA","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport { get, flatMap } from 'lodash';\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Returns the annotations for a specific client ID.\n *\n * @param {Object} state Editor state.\n * @param {string} clientId The ID of the block to get the annotations for.\n *\n * @return {Array} The annotations applicable to this block.\n */\nexport const __experimentalGetAnnotationsForBlock = createSelector(\n\t( state, blockClientId ) => {\n\t\treturn get( state, blockClientId, [] ).filter( ( annotation ) => {\n\t\t\treturn annotation.selector === 'block';\n\t\t} );\n\t},\n\t( state, blockClientId ) => [\n\t\tget( state, blockClientId, EMPTY_ARRAY ),\n\t]\n);\n\nexport const __experimentalGetAllAnnotationsForBlock = function( state, blockClientId ) {\n\treturn get( state, blockClientId, EMPTY_ARRAY );\n};\n\n/**\n * Returns the annotations that apply to the given RichText instance.\n *\n * Both a blockClientId and a richTextIdentifier are required. This is because\n * a block might have multiple `RichText` components. This does mean that every\n * block needs to implement annotations itself.\n *\n * @param {Object} state              Editor state.\n * @param {string} blockClientId      The client ID for the block.\n * @param {string} richTextIdentifier Unique identifier that identifies the given RichText.\n * @return {Array} All the annotations relevant for the `RichText`.\n */\nexport const __experimentalGetAnnotationsForRichText = createSelector(\n\t( state, blockClientId, richTextIdentifier ) => {\n\t\treturn get( state, blockClientId, [] ).filter( ( annotation ) => {\n\t\t\treturn annotation.selector === 'range' &&\n\t\t\t\trichTextIdentifier === annotation.richTextIdentifier;\n\t\t} ).map( ( annotation ) => {\n\t\t\tconst { range, ...other } = annotation;\n\n\t\t\treturn {\n\t\t\t\t...range,\n\t\t\t\t...other,\n\t\t\t};\n\t\t} );\n\t},\n\t( state, blockClientId ) => [\n\t\tget( state, blockClientId, EMPTY_ARRAY ),\n\t]\n);\n\n/**\n * Returns all annotations in the editor state.\n *\n * @param {Object} state Editor state.\n * @return {Array} All annotations currently applied.\n */\nexport function __experimentalGetAnnotations( state ) {\n\treturn flatMap( state, ( annotations ) => {\n\t\treturn annotations;\n\t} );\n}\n"]}