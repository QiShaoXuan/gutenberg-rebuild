{"version":3,"sources":["@wordpress/rich-text/src/apply-format.native.js"],"names":["applyFormat","value","formats","startIndex","start","endIndex","end","currentFormats","formatPlaceholder","Array","isArray","previousFormats","placeholderFormats","index","activeFormats","mergeFormats","newFormats","slice","applyFormats","formats1","formats2","formatsOut","forEach","format2","format1In2","find","format1","type","Object","assign","push"],"mappings":";;;;;;;;;;;AAIA;;AAMA;;AAVA;;;;AAMA;;;;AAMA;;;;;;;;;;;;AAYO,SAASA,WAAT,CACNC,KADM,EAENC,OAFM,EAKL;AAAA,MAFDC,UAEC,uEAFYF,KAAK,CAACG,KAElB;AAAA,MADDC,QACC,uEADUJ,KAAK,CAACK,GAChB;AAAA,MACgBC,cADhB,GAC6DN,KAD7D,CACOC,OADP;AAAA,MACgCM,iBADhC,GAC6DP,KAD7D,CACgCO,iBADhC;AAAA,MACmDJ,KADnD,GAC6DH,KAD7D,CACmDG,KADnD;;AAGD,MAAK,CAAEK,KAAK,CAACC,OAAN,CAAeR,OAAf,CAAP,EAAkC;AACjCA,IAAAA,OAAO,GAAG,CAAEA,OAAF,CAAV;AACA,GALA,CAOD;AACA;;;AACA,MAAKC,UAAU,KAAKE,QAApB,EAA+B;AAC9B,QAAMM,eAAe,GAAGJ,cAAc,CAAEJ,UAAU,GAAG,CAAf,CAAd,IAAoC,EAA5D;AACA,QAAMS,kBAAkB,GAAGJ,iBAAiB,IAAIA,iBAAiB,CAACK,KAAlB,KAA4BT,KAAjD,IAA0DI,iBAAiB,CAACN,OAAvG,CAF8B,CAG9B;;AACA,QAAMY,aAAa,GAAG,CAAEF,kBAAkB,GAAGA,kBAAH,GAAwBD,eAA5C,KAAiE,EAAvF;AACA,2CACIV,KADJ;AAECC,MAAAA,OAAO,EAAEK,cAFV;AAGCC,MAAAA,iBAAiB,EAAE;AAClBK,QAAAA,KAAK,EAAET,KADW;AAElBF,QAAAA,OAAO,EAAEa,YAAY,CAAED,aAAF,EAAiBZ,OAAjB;AAFH;AAHpB;AAQA;;AAED,MAAMc,UAAU,GAAGT,cAAc,CAACU,KAAf,CAAsB,CAAtB,CAAnB;;AAEA,OAAM,IAAIJ,KAAK,GAAGV,UAAlB,EAA8BU,KAAK,GAAGR,QAAtC,EAAgDQ,KAAK,EAArD,EAA0D;AACzDK,IAAAA,YAAY,CAAEF,UAAF,EAAcH,KAAd,EAAqBX,OAArB,CAAZ;AACA;;AAED,SAAO,wEAAuBD,KAAvB;AAA8BC,IAAAA,OAAO,EAAEc;AAAvC,KAAP;AACA;;AAED,SAASD,YAAT,CAAuBI,QAAvB,EAAiCC,QAAjC,EAA4C;AAC3C,MAAMC,UAAU,GAAG,uBAAWF,QAAX,CAAnB;AACAC,EAAAA,QAAQ,CAACE,OAAT,CAAkB,UAAEC,OAAF,EAAe;AAChC,QAAMC,UAAU,GAAGH,UAAU,CAACI,IAAX,CAAiB,UAAEC,OAAF;AAAA,aAAeA,OAAO,CAACC,IAAR,KAAiBJ,OAAO,CAACI,IAAxC;AAAA,KAAjB,CAAnB,CADgC,CAEhC;;AACA,QAAKH,UAAL,EAAkB;AACjBI,MAAAA,MAAM,CAACC,MAAP,CAAeL,UAAf,EAA2BD,OAA3B;AACA,KAFD,MAEO;AACNF,MAAAA,UAAU,CAACS,IAAX,CAAiB,uBAAWP,OAAX,CAAjB;AACA;AACD,GARD;AASA,SAAOF,UAAP;AACA;;AAED,SAASH,YAAT,CAAuBhB,OAAvB,EAAgCW,KAAhC,EAAuCG,UAAvC,EAAoD;AACnD,MAAKd,OAAO,CAAEW,KAAF,CAAZ,EAAwB;AACvBX,IAAAA,OAAO,CAAEW,KAAF,CAAP,GAAmBE,YAAY,CAAEb,OAAO,CAAEW,KAAF,CAAT,EAAoBG,UAApB,CAA/B;AACA,GAFD,MAEO;AACNd,IAAAA,OAAO,CAAEW,KAAF,CAAP,GAAmB,uBAAWG,UAAX,CAAnB;AACA;AACD","sourcesContent":["/**\n * External dependencies\n */\n\nimport { cloneDeep } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} formats    Formats to apply.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformats,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats: currentFormats, formatPlaceholder, start } = value;\n\n\tif ( ! Array.isArray( formats ) ) {\n\t\tformats = [ formats ];\n\t}\n\n\t// The selection is collpased, insert a placeholder with the format so new input appears\n\t// with the format applied.\n\tif ( startIndex === endIndex ) {\n\t\tconst previousFormats = currentFormats[ startIndex - 1 ] || [];\n\t\tconst placeholderFormats = formatPlaceholder && formatPlaceholder.index === start && formatPlaceholder.formats;\n\t\t// Follow the same logic as in getActiveFormat: placeholderFormats has priority over previousFormats\n\t\tconst activeFormats = ( placeholderFormats ? placeholderFormats : previousFormats ) || [];\n\t\treturn {\n\t\t\t...value,\n\t\t\tformats: currentFormats,\n\t\t\tformatPlaceholder: {\n\t\t\t\tindex: start,\n\t\t\t\tformats: mergeFormats( activeFormats, formats ),\n\t\t\t},\n\t\t};\n\t}\n\n\tconst newFormats = currentFormats.slice( 0 );\n\n\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\tapplyFormats( newFormats, index, formats );\n\t}\n\n\treturn normaliseFormats( { ...value, formats: newFormats } );\n}\n\nfunction mergeFormats( formats1, formats2 ) {\n\tconst formatsOut = cloneDeep( formats1 );\n\tformats2.forEach( ( format2 ) => {\n\t\tconst format1In2 = formatsOut.find( ( format1 ) => format1.type === format2.type );\n\t\t// update properties while keeping the formats ordered\n\t\tif ( format1In2 ) {\n\t\t\tObject.assign( format1In2, format2 );\n\t\t} else {\n\t\t\tformatsOut.push( cloneDeep( format2 ) );\n\t\t}\n\t} );\n\treturn formatsOut;\n}\n\nfunction applyFormats( formats, index, newFormats ) {\n\tif ( formats[ index ] ) {\n\t\tformats[ index ] = mergeFormats( formats[ index ], newFormats );\n\t} else {\n\t\tformats[ index ] = cloneDeep( newFormats );\n\t}\n}\n"]}