{"version":3,"sources":["@wordpress/rich-text/src/to-dom.js"],"names":["TEXT_NODE","window","Node","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","createEmpty","document","append","element","child","ownerDocument","createTextNode","type","attributes","createElement","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","getText","nodeValue","remove","removeChild","prepareFormats","prepareEditableTree","value","reduce","accumlator","fn","formats","toDom","multilineTag","isEditableTree","startPath","endPath","tree","onStartIndex","body","pointer","onEndIndex","selection","apply","current","__unstableDomOnly","applyValue","start","undefined","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","nodeName","data","replaceChild","currentAttributes","futureAttributes","ii","name","getAttribute","removeAttribute","isRangeEqual","a","b","startContainer","startOffset","endContainer","endOffset","getSelection","range","createRange","setStart","setEnd","rangeCount","getRangeAt","activeElement","focus","removeAllRanges","addRange"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\n/**\n * Returns a new instance of a DOM tree upon which RichText operations can be\n * applied.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createEmpty`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @return {WPRichTextTree} RichText tree.\n */\nconst createEmpty = () => createElement( document, '' );\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nfunction prepareFormats( prepareEditableTree = [], value ) {\n\treturn prepareEditableTree.reduce( ( accumlator, fn ) => {\n\t\treturn fn( accumlator, value.text );\n\t}, value.formats );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tprepareEditableTree,\n\tisEditableTree = true,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( {\n\t\tvalue: {\n\t\t\t...value,\n\t\t\tformats: prepareFormats( prepareEditableTree, value ),\n\t\t},\n\t\tmultilineTag,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tisEditableTree,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      $1                        Named arguments.\n * @param {Object}      $1.value                  Value to apply.\n * @param {HTMLElement} $1.current                The live root node to apply the element tree to.\n * @param {string}      [$1.multilineTag]         Multiline tag.\n * @param {Array}       [$1.multilineWrapperTags] Tags where lines can be found if nesting is possible.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tprepareEditableTree,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === TEXT_NODE && currentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < currentAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range} a First range object to test.\n * @param {Range} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual( a, b ) {\n\treturn (\n\t\ta.startContainer === b.startContainer &&\n\t\ta.startOffset === b.startOffset &&\n\t\ta.endContainer === b.endContainer &&\n\t\ta.endOffset === b.endOffset\n\t);\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, endPath );\n\tconst selection = window.getSelection();\n\tconst { ownerDocument } = current;\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\t// Set back focus if focus is lost.\n\t\t\tif ( ownerDocument.activeElement !== current ) {\n\t\t\t\tcurrent.focus();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n}\n"]}