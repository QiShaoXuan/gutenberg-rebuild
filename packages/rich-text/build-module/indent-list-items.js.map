{"version":3,"sources":["@wordpress/rich-text/src/indent-list-items.js"],"names":["LINE_SEPARATOR","getLineIndex","getTargetLevelLineIndex","lineIndex","text","replacements","startFormats","index","formatsAtIndex","length","indentListItems","value","rootFormat","undefined","end","previousLineIndex","formatsAtLineIndex","formatsAtPreviousLineIndex","newFormats","slice","targetLevelLineIndex","targetFormats","concat","lastformat"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\n\n/**\n * Gets the line index of the first previous list item with higher indentation.\n *\n * @param {Object} value      Value to search.\n * @param {number} lineIndex  Line index of the list item to compare with.\n *\n * @return {boolean} The line index.\n */\nfunction getTargetLevelLineIndex( { text, replacements }, lineIndex ) {\n\tconst startFormats = replacements[ lineIndex ] || [];\n\n\tlet index = lineIndex;\n\n\twhile ( index-- >= 0 ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\t// Return the first line index that is one level higher. If the level is\n\t\t// lower or equal, there is no result.\n\t\tif ( formatsAtIndex.length === startFormats.length + 1 ) {\n\t\t\treturn index;\n\t\t} else if ( formatsAtIndex.length <= startFormats.length ) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/**\n * Indents any selected list items if possible.\n *\n * @param {Object} value      Value to change.\n * @param {Object} rootFormat Root format.\n *\n * @return {Object} The changed value.\n */\nexport function indentListItems( value, rootFormat ) {\n\tconst lineIndex = getLineIndex( value );\n\n\t// There is only one line, so the line cannot be indented.\n\tif ( lineIndex === undefined ) {\n\t\treturn value;\n\t}\n\n\tconst { text, replacements, end } = value;\n\tconst previousLineIndex = getLineIndex( value, lineIndex );\n\tconst formatsAtLineIndex = replacements[ lineIndex ] || [];\n\tconst formatsAtPreviousLineIndex = replacements[ previousLineIndex ] || [];\n\n\t// The the indentation of the current line is greater than previous line,\n\t// then the line cannot be furter indented.\n\tif ( formatsAtLineIndex.length > formatsAtPreviousLineIndex.length ) {\n\t\treturn value;\n\t}\n\n\tconst newFormats = replacements.slice();\n\tconst targetLevelLineIndex = getTargetLevelLineIndex( value, lineIndex );\n\n\tfor ( let index = lineIndex; index < end; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get the previous list, and if there's a child list, take over the\n\t\t// formats. If not, duplicate the last level and create a new level.\n\t\tif ( targetLevelLineIndex ) {\n\t\t\tconst targetFormats = replacements[ targetLevelLineIndex ] || [];\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length - 1 )\n\t\t\t);\n\t\t} else {\n\t\t\tconst targetFormats = replacements[ previousLineIndex ] || [];\n\t\t\tconst lastformat = targetFormats[ targetFormats.length - 1 ] || rootFormat;\n\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t[ lastformat ],\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length )\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newFormats,\n\t};\n}\n"]}