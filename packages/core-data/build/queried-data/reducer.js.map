{"version":3,"sources":["@wordpress/core-data/src/queried-data/reducer.js"],"names":["getMergedItemIds","itemIds","nextItemIds","page","perPage","nextItemIdsStartIndex","size","Math","max","length","mergedItemIds","Array","i","isInNextItemsRange","items","state","action","type","key","DEFAULT_ENTITY_KEY","queries","query"],"mappings":";;;;;;;;;;;;AAGA;;AACA;;AAKA;;AAKA;;AACA;;AAfA;;;;AAMA;;;;AAWA;;;;;;;;;;;AAWO,SAASA,gBAAT,CAA2BC,OAA3B,EAAoCC,WAApC,EAAiDC,IAAjD,EAAuDC,OAAvD,EAAiE;AACvE,MAAMC,qBAAqB,GAAG,CAAEF,IAAI,GAAG,CAAT,IAAeC,OAA7C,CADuE,CAGvE;AACA;;AACA,MAAME,IAAI,GAAGC,IAAI,CAACC,GAAL,CACZP,OAAO,CAACQ,MADI,EAEZJ,qBAAqB,GAAGH,WAAW,CAACO,MAFxB,CAAb,CALuE,CAUvE;;AACA,MAAMC,aAAa,GAAG,IAAIC,KAAJ,CAAWL,IAAX,CAAtB;;AAEA,OAAM,IAAIM,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGN,IAArB,EAA2BM,CAAC,EAA5B,EAAiC;AAChC;AACA,QAAMC,kBAAkB,GACvBD,CAAC,IAAIP,qBAAL,IACAO,CAAC,GAAGP,qBAAqB,GAAGH,WAAW,CAACO,MAFzC;AAKAC,IAAAA,aAAa,CAAEE,CAAF,CAAb,GAAqBC,kBAAkB,GACtCX,WAAW,CAAEU,CAAC,GAAGP,qBAAN,CAD2B,GAEtCJ,OAAO,CAAEW,CAAF,CAFR;AAGA;;AAED,SAAOF,aAAP;AACA;AAED;;;;;;;;;;;AASA,SAASI,KAAT,GAAqC;AAAA,MAArBC,KAAqB,uEAAb,EAAa;AAAA,MAATC,MAAS;;AACpC,UAASA,MAAM,CAACC,IAAhB;AACC,SAAK,eAAL;AACC,6CACIF,KADJ,EAEI,mBAAOC,MAAM,CAACF,KAAd,EAAqBE,MAAM,CAACE,GAAP,IAAcC,4BAAnC,CAFJ;AAFF;;AAQA,SAAOJ,KAAP;AACA;AAED;;;;;;;;;;;AASA,IAAMK,OAAO,GAAG,uBAAW,CAC1B;AACA;AACA,6BAAkB,UAAEJ,MAAF;AAAA,SAAc,WAAWA,MAAzB;AAAA,CAAlB,CAH0B,EAK1B;AACA,0BAAe,UAAEA,MAAF,EAAc;AAC5B;AACA;AACA;AACA,MAAKA,MAAM,CAACK,KAAZ,EAAoB;AACnB,2CACIL,MADJ,EAEI,4BAAeA,MAAM,CAACK,KAAtB,CAFJ;AAIA;;AAED,SAAOL,MAAP;AACA,CAZD,CAN0B,EAoB1B;AACA;AACA,qBAAU,WAAV,CAtB0B,CAAX,EAuBX,YAA4B;AAAA,MAA1BD,KAA0B,uEAAlB,IAAkB;AAAA,MAAZC,MAAY;AAAA,MACxBC,IADwB,GAC0BD,MAD1B,CACxBC,IADwB;AAAA,MAClBd,IADkB,GAC0Ba,MAD1B,CAClBb,IADkB;AAAA,MACZC,OADY,GAC0BY,MAD1B,CACZZ,OADY;AAAA,oBAC0BY,MAD1B,CACHE,GADG;AAAA,MACHA,GADG,4BACGC,4BADH;;AAGhC,MAAKF,IAAI,KAAK,eAAd,EAAgC;AAC/B,WAAOF,KAAP;AACA;;AAED,SAAOf,gBAAgB,CACtBe,KAAK,IAAI,EADa,EAEtB,iBAAKC,MAAM,CAACF,KAAZ,EAAmBI,GAAnB,CAFsB,EAGtBf,IAHsB,EAItBC,OAJsB,CAAvB;AAMA,CApCe,CAAhB;;eAsCe,4BAAiB;AAC/BU,EAAAA,KAAK,EAALA,KAD+B;AAE/BM,EAAAA,OAAO,EAAPA;AAF+B,CAAjB,C","sourcesContent":["/**\n * External dependencies\n */\nimport { combineReducers } from 'redux';\nimport { keyBy, map, flowRight } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport {\n\tifMatchingAction,\n\treplaceAction,\n\tonSubKey,\n} from '../utils';\nimport { DEFAULT_ENTITY_KEY } from '../entities';\nimport getQueryParts from './get-query-parts';\n\n/**\n * Returns a merged array of item IDs, given details of the received paginated\n * items. The array is sparse-like with `undefined` entries where holes exist.\n *\n * @param {?Array<number>} itemIds     Original item IDs (default empty array).\n * @param {number[]}       nextItemIds Item IDs to merge.\n * @param {number}         page        Page of items merged.\n * @param {number}         perPage     Number of items per page.\n *\n * @return {number[]} Merged array of item IDs.\n */\nexport function getMergedItemIds( itemIds, nextItemIds, page, perPage ) {\n\tconst nextItemIdsStartIndex = ( page - 1 ) * perPage;\n\n\t// If later page has already been received, default to the larger known\n\t// size of the existing array, else calculate as extending the existing.\n\tconst size = Math.max(\n\t\titemIds.length,\n\t\tnextItemIdsStartIndex + nextItemIds.length\n\t);\n\n\t// Preallocate array since size is known.\n\tconst mergedItemIds = new Array( size );\n\n\tfor ( let i = 0; i < size; i++ ) {\n\t\t// Preserve existing item ID except for subset of range of next items.\n\t\tconst isInNextItemsRange = (\n\t\t\ti >= nextItemIdsStartIndex &&\n\t\t\ti < nextItemIdsStartIndex + nextItemIds.length\n\t\t);\n\n\t\tmergedItemIds[ i ] = isInNextItemsRange ?\n\t\t\tnextItemIds[ i - nextItemIdsStartIndex ] :\n\t\t\titemIds[ i ];\n\t}\n\n\treturn mergedItemIds;\n}\n\n/**\n * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\n * where identifiers are common across all queries.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nfunction items( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...keyBy( action.items, action.key || DEFAULT_ENTITY_KEY ),\n\t\t\t};\n\t}\n\n\treturn state;\n}\n\n/**\n * Reducer tracking queries state, keyed by stable query key. Each reducer\n * query object includes `itemIds` and `requestingPageByPerPage`.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst queries = flowRight( [\n\t// Limit to matching action type so we don't attempt to replace action on\n\t// an unhandled action.\n\tifMatchingAction( ( action ) => 'query' in action ),\n\n\t// Inject query parts into action for use both in `onSubKey` and reducer.\n\treplaceAction( ( action ) => {\n\t\t// `ifMatchingAction` still passes on initialization, where state is\n\t\t// undefined and a query is not assigned. Avoid attempting to parse\n\t\t// parts. `onSubKey` will omit by lack of `stableKey`.\n\t\tif ( action.query ) {\n\t\t\treturn {\n\t\t\t\t...action,\n\t\t\t\t...getQueryParts( action.query ),\n\t\t\t};\n\t\t}\n\n\t\treturn action;\n\t} ),\n\n\t// Queries shape is shared, but keyed by query `stableKey` part. Original\n\t// reducer tracks only a single query object.\n\tonSubKey( 'stableKey' ),\n] )( ( state = null, action ) => {\n\tconst { type, page, perPage, key = DEFAULT_ENTITY_KEY } = action;\n\n\tif ( type !== 'RECEIVE_ITEMS' ) {\n\t\treturn state;\n\t}\n\n\treturn getMergedItemIds(\n\t\tstate || [],\n\t\tmap( action.items, key ),\n\t\tpage,\n\t\tperPage\n\t);\n} );\n\nexport default combineReducers( {\n\titems,\n\tqueries,\n} );\n"]}